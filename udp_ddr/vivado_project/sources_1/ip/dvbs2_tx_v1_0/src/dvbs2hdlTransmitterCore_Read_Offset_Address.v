// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Read_Offset_Address.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Read_Offset_Address
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator/Read Offset 
// Addres
// Hierarchy Level: 6
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Read_Offset_Address
          (clk,
           reset,
           enb,
           maxR,
           maxC,
           modcodIs12,
           wrAddr,
           wrEnb,
           modIdx,
           readAddr,
           readValid,
           startOut,
           endOut);


  input   clk;
  input   reset;
  input   enb;
  input   [15:0] maxR;  // uint16
  input   [2:0] maxC;  // ufix3
  input   modcodIs12;
  input   [15:0] wrAddr;  // uint16
  input   wrEnb;
  input   [1:0] modIdx;  // ufix2
  output  [16:0] readAddr;  // ufix17
  output  readValid;
  output  startOut;
  output  endOut;


  reg [15:0] Delay_reg [0:3];  // ufix16 [4]
  reg [15:0] Delay_reg_next [0:3];  // ufix16 [4]
  reg [15:0] Delay_out1;  // uint16
  wire [15:0] Generate_Signal_for_End_of_Frame_out1;  // uint16
  reg [2:0] Delay1_reg [0:3];  // ufix3 [4]
  reg [2:0] Delay1_reg_next [0:3];  // ufix3 [4]
  reg [2:0] Delay1_out1;  // ufix3
  reg  [3:0] Delay2_reg;  // ufix1 [4]
  wire Delay2_out1;
  reg [15:0] Delay3_reg [0:3];  // ufix16 [4]
  reg [15:0] Delay3_reg_next [0:3];  // ufix16 [4]
  reg [15:0] Delay3_out1;  // uint16
  reg  [3:0] Delay4_reg;  // ufix1 [4]
  wire Delay4_out1;
  reg [1:0] Delay7_reg [0:3];  // ufix2 [4]
  reg [1:0] Delay7_reg_next [0:3];  // ufix2 [4]
  reg [1:0] Delay7_out1;  // ufix2
  wire [2:0] curCorROut;  // ufix3
  wire [15:0] maxRorCOut;  // uint16
  wire [15:0] curRorCOut;  // uint16
  wire startOut_1;
  wire endOut_1;
  wire readValid_1;
  wire [16:0] Compute_Read_Offset_Address_out1;  // ufix17
  reg  [3:0] Delay9_reg;  // ufix1 [4]
  wire Delay9_out1;
  reg  [3:0] Delay6_reg;  // ufix1 [4]
  wire Delay6_out1;
  reg  [3:0] Delay5_reg;  // ufix1 [4]
  wire Delay5_out1;
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_0_1;  // int32
  reg signed [31:0] Delay_t_1;  // int32
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_0_1;  // int32
  reg signed [31:0] Delay1_t_1;  // int32
  reg signed [31:0] Delay3_t_0_0;  // int32
  reg signed [31:0] Delay3_t_0_1;  // int32
  reg signed [31:0] Delay3_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd3; Delay_t_1 = Delay_t_1 + 32'sd1) begin
          Delay_reg[Delay_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay_t_0_1 = 32'sd0; Delay_t_0_1 <= 32'sd3; Delay_t_0_1 = Delay_t_0_1 + 32'sd1) begin
            Delay_reg[Delay_t_0_1] <= Delay_reg_next[Delay_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay_out1 = Delay_reg[3];
    Delay_reg_next[0] = maxR;

    for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd2; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
      Delay_reg_next[Delay_t_0_0 + 32'sd1] = Delay_reg[Delay_t_0_0];
    end

  end



  dvbs2hdlTransmitterCore_Generate_Signal_for_End_of_Frame u_Generate_Signal_for_End_of_Frame (.clk(clk),
                                                                                               .reset(reset),
                                                                                               .enb(enb),
                                                                                               .maxR(maxR),  // uint16
                                                                                               .maxC(maxC),  // ufix3
                                                                                               .chkwrAddrEnd(Generate_Signal_for_End_of_Frame_out1)  // uint16
                                                                                               );

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd3; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg[Delay1_t_1] <= 3'b000;
        end
      end
      else begin
        if (enb) begin
          for(Delay1_t_0_1 = 32'sd0; Delay1_t_0_1 <= 32'sd3; Delay1_t_0_1 = Delay1_t_0_1 + 32'sd1) begin
            Delay1_reg[Delay1_t_0_1] <= Delay1_reg_next[Delay1_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay1_out1 = Delay1_reg[3];
    Delay1_reg_next[0] = maxC;

    for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd2; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
      Delay1_reg_next[Delay1_t_0_0 + 32'sd1] = Delay1_reg[Delay1_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= modcodIs12;
          Delay2_reg[32'sd3:32'sd1] <= Delay2_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        for(Delay3_t_1 = 32'sd0; Delay3_t_1 <= 32'sd3; Delay3_t_1 = Delay3_t_1 + 32'sd1) begin
          Delay3_reg[Delay3_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay3_t_0_1 = 32'sd0; Delay3_t_0_1 <= 32'sd3; Delay3_t_0_1 = Delay3_t_0_1 + 32'sd1) begin
            Delay3_reg[Delay3_t_0_1] <= Delay3_reg_next[Delay3_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay3_out1 = Delay3_reg[3];
    Delay3_reg_next[0] = wrAddr;

    for(Delay3_t_0_0 = 32'sd0; Delay3_t_0_0 <= 32'sd2; Delay3_t_0_0 = Delay3_t_0_0 + 32'sd1) begin
      Delay3_reg_next[Delay3_t_0_0 + 32'sd1] = Delay3_reg[Delay3_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= wrEnb;
          Delay4_reg[32'sd3:32'sd1] <= Delay4_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd3; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd3; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
            Delay7_reg[Delay7_t_0_1] <= Delay7_reg_next[Delay7_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay7_out1 = Delay7_reg[3];
    Delay7_reg_next[0] = modIdx;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd2; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next[Delay7_t_0_0 + 32'sd1] = Delay7_reg[Delay7_t_0_0];
    end

  end



  dvbs2hdlTransmitterCore_Read_Offset_Address_Signals_Generator u_Read_Offset_Address_Signals_Generator (.clk(clk),
                                                                                                         .reset(reset),
                                                                                                         .enb(enb),
                                                                                                         .maxR(Delay_out1),  // uint16
                                                                                                         .chkwrAddrEnd(Generate_Signal_for_End_of_Frame_out1),  // uint16
                                                                                                         .maxC(Delay1_out1),  // ufix3
                                                                                                         .modcodIs12(Delay2_out1),
                                                                                                         .wrAddr(Delay3_out1),  // uint16
                                                                                                         .wrEnb(Delay4_out1),
                                                                                                         .modIdx(Delay7_out1),  // ufix2
                                                                                                         .curCorROut(curCorROut),  // ufix3
                                                                                                         .maxRorCOut(maxRorCOut),  // uint16
                                                                                                         .curRorCOut(curRorCOut),  // uint16
                                                                                                         .startOut(startOut_1),
                                                                                                         .endOut(endOut_1),
                                                                                                         .readValid(readValid_1)
                                                                                                         );

  dvbs2hdlTransmitterCore_Compute_Read_Offset_Address u_Compute_Read_Offset_Address (.clk(clk),
                                                                                     .enb(enb),
                                                                                     .curR(curCorROut),  // ufix3
                                                                                     .maxC(maxRorCOut),  // uint16
                                                                                     .curC(curRorCOut),  // uint16
                                                                                     .addr(Compute_Read_Offset_Address_out1)  // ufix17
                                                                                     );

  assign readAddr = Compute_Read_Offset_Address_out1;

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay9_reg[0] <= readValid_1;
          Delay9_reg[32'sd3:32'sd1] <= Delay9_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[3];



  assign readValid = Delay9_out1;

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay6_reg[0] <= startOut_1;
          Delay6_reg[32'sd3:32'sd1] <= Delay6_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[3];



  assign startOut = Delay6_out1;

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay5_reg[0] <= endOut_1;
          Delay5_reg[32'sd3:32'sd1] <= Delay5_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[3];



  assign endOut = Delay5_out1;

endmodule  // dvbs2hdlTransmitterCore_Read_Offset_Address

