// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Dummy_Frame_Header_LUT_Address_Generator.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Dummy_Frame_Header_LUT_Address_Generator
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/PL Frame Generator/RAM FIFO/PL Data FIFO/Dummy Frame Generator/Dummy 
// Frame Header LUT Address Generato
// Hierarchy Level: 7
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Dummy_Frame_Header_LUT_Address_Generator
          (clk,
           reset,
           enb_1_8_0,
           nextFrameReady,
           EOF,
           countOut,
           validm2,
           valid);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   nextFrameReady;
  input   EOF;
  output  [11:0] countOut;  // ufix12
  output  validm2;
  output  valid;


  wire stateControl_1;
  reg  [1:0] delayMatch_reg;  // ufix1 [2]
  wire stateControl_2;
  wire enb_1_8_0_gated;
  reg [11:0] countOut_1;  // ufix12
  reg  validm2_1;
  reg  valid_1;
  reg [11:0] count;  // ufix12
  reg  countActive;
  reg [11:0] count_next;  // ufix12
  reg  countActive_next;
  wire [11:0] countOut_bypass;  // ufix12
  reg [11:0] countOut_last_value;  // ufix12
  wire validm2_bypass;
  reg  validm2_last_value;
  wire valid_bypass;
  reg  valid_last_value;
  reg  countActive_temp;


  assign stateControl_1 = 1'b1;



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          delayMatch_reg[0] <= stateControl_1;
          delayMatch_reg[1] <= delayMatch_reg[0];
        end
      end
    end

  assign stateControl_2 = delayMatch_reg[1];



  assign enb_1_8_0_gated = stateControl_2 && enb_1_8_0;

  always @(posedge clk or posedge reset)
    begin : Dummy_Frame_Header_LUT_Address_Generator_process
      if (reset == 1'b1) begin
        count <= 12'b000000000000;
        countActive <= 1'b0;
      end
      else begin
        if (enb_1_8_0_gated) begin
          count <= count_next;
          countActive <= countActive_next;
        end
      end
    end

  always @(EOF, count, countActive, nextFrameReady) begin
    countActive_temp = countActive;
    count_next = count;
    if ((( ! countActive) && EOF) && ( ! nextFrameReady)) begin
      countActive_temp = 1'b1;
    end
    valid_1 = countActive_temp;
    validm2_1 = countActive_temp && (count <= 12'b110011111111);
    if (countActive_temp) begin
      if (count == 12'b110100000001) begin
        count_next = 12'b000000000000;
        countActive_temp = 1'b0;
      end
      else begin
        count_next = count + 12'b000000000001;
      end
    end
    countOut_1 = count;
    countActive_next = countActive_temp;
  end



  always @(posedge clk or posedge reset)
    begin : out0_bypass_process
      if (reset == 1'b1) begin
        countOut_last_value <= 12'b000000000000;
      end
      else begin
        if (enb_1_8_0_gated) begin
          countOut_last_value <= countOut_bypass;
        end
      end
    end



  assign countOut_bypass = (stateControl_2 == 1'b0 ? countOut_last_value :
              countOut_1);



  assign countOut = countOut_bypass;

  always @(posedge clk or posedge reset)
    begin : out1_bypass_process
      if (reset == 1'b1) begin
        validm2_last_value <= 1'b0;
      end
      else begin
        if (enb_1_8_0_gated) begin
          validm2_last_value <= validm2_bypass;
        end
      end
    end



  assign validm2_bypass = (stateControl_2 == 1'b0 ? validm2_last_value :
              validm2_1);



  assign validm2 = validm2_bypass;

  always @(posedge clk or posedge reset)
    begin : out2_bypass_process
      if (reset == 1'b1) begin
        valid_last_value <= 1'b0;
      end
      else begin
        if (enb_1_8_0_gated) begin
          valid_last_value <= valid_bypass;
        end
      end
    end



  assign valid_bypass = (stateControl_2 == 1'b0 ? valid_last_value :
              valid_1);



  assign valid = valid_bypass;

endmodule  // dvbs2hdlTransmitterCore_Dummy_Frame_Header_LUT_Address_Generator

