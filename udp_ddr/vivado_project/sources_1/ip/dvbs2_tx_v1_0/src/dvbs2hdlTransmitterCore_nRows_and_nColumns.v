// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_nRows_and_nColumns.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_nRows_and_nColumns
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator/nRows 
// and nColumn
// Hierarchy Level: 6
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_nRows_and_nColumns
          (clk,
           reset,
           enb,
           captureIn,
           modIdx,
           codIdx,
           fecFrame,
           captureOut,
           modIdxOut,
           codIdxOut,
           fecFrameOut,
           maxR,
           maxC,
           isMODOCD12);


  input   clk;
  input   reset;
  input   enb;
  input   captureIn;
  input   [1:0] modIdx;  // ufix2
  input   [3:0] codIdx;  // ufix4
  input   fecFrame;
  output  captureOut;
  output  [1:0] modIdxOut;  // ufix2
  output  [3:0] codIdxOut;  // ufix4
  output  fecFrameOut;
  output  [15:0] maxR;  // uint16
  output  [2:0] maxC;  // ufix3
  output  isMODOCD12;


  reg  [3:0] Delay4_reg;  // ufix1 [4]
  wire Delay4_out1;
  reg [1:0] Delay7_reg [0:3];  // ufix2 [4]
  reg [1:0] Delay7_reg_next [0:3];  // ufix2 [4]
  reg [1:0] Delay7_out1;  // ufix2
  reg [3:0] Delay8_reg [0:3];  // ufix4 [4]
  reg [3:0] Delay8_reg_next [0:3];  // ufix4 [4]
  reg [3:0] Delay8_out1;  // ufix4
  reg  [3:0] Delay3_reg;  // ufix1 [4]
  wire Delay3_out1;
  reg [1:0] Delay9_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay9_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay9_out1;  // ufix2
  wire [1:0] prelookup_idx_sat;  // ufix2
  wire [15:0] MaxR_Normal_LUT_1 [0:3];  // ufix16 [4]
  wire [15:0] MaxR_Normal_LUT_out1;  // uint16
  reg [15:0] Delay14_reg [0:1];  // ufix16 [2]
  wire [15:0] Delay14_reg_next [0:1];  // ufix16 [2]
  wire [15:0] Delay14_out1;  // uint16
  reg [1:0] Delay10_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay10_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay10_out1;  // ufix2
  wire [1:0] prelookup_idx_sat_1;  // ufix2
  wire [13:0] MaxR_Short_LUT_1 [0:3];  // ufix14 [4]
  wire [13:0] MaxR_Short_LUT_out1;  // ufix14
  reg [13:0] Delay13_reg [0:1];  // ufix14 [2]
  wire [13:0] Delay13_reg_next [0:1];  // ufix14 [2]
  wire [13:0] Delay13_out1;  // ufix14
  wire [15:0] Data_Type_Conversion_out1;  // uint16
  wire [15:0] maxR_switch_out1;  // uint16
  reg [1:0] Delay11_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay11_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay11_out1;  // ufix2
  wire [1:0] prelookup_idx_sat_2;  // ufix2
  wire [2:0] MaxC_LUT_1 [0:3];  // ufix3 [4]
  wire [2:0] MaxC_LUT_out1;  // ufix3
  reg [2:0] Delay12_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay12_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay12_out1;  // ufix3
  wire Compare_To_Constant_out1;
  wire Compare_To_Constant1_out1;
  wire Logical_Operator_out1;
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32
  reg signed [31:0] Delay8_t_0_0;  // int32
  reg signed [31:0] Delay8_t_0_1;  // int32
  reg signed [31:0] Delay8_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] Delay14_t_0_0;  // int32
  reg signed [31:0] Delay14_t_1;  // int32
  reg signed [31:0] Delay10_t_0_0;  // int32
  reg signed [31:0] Delay10_t_1;  // int32
  reg signed [31:0] Delay13_t_0_0;  // int32
  reg signed [31:0] Delay13_t_1;  // int32
  reg signed [31:0] Delay11_t_0_0;  // int32
  reg signed [31:0] Delay11_t_1;  // int32
  reg signed [31:0] Delay12_t_0_0;  // int32
  reg signed [31:0] Delay12_t_1;  // int32

  initial begin

    for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd1; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
      Delay9_reg[Delay9_t_1] = 2'b00;
    end


    for(Delay14_t_1 = 32'sd0; Delay14_t_1 <= 32'sd1; Delay14_t_1 = Delay14_t_1 + 32'sd1) begin
      Delay14_reg[Delay14_t_1] = 16'b0000000000000000;
    end


    for(Delay10_t_1 = 32'sd0; Delay10_t_1 <= 32'sd1; Delay10_t_1 = Delay10_t_1 + 32'sd1) begin
      Delay10_reg[Delay10_t_1] = 2'b00;
    end


    for(Delay13_t_1 = 32'sd0; Delay13_t_1 <= 32'sd1; Delay13_t_1 = Delay13_t_1 + 32'sd1) begin
      Delay13_reg[Delay13_t_1] = 14'b00000000000000;
    end


    for(Delay11_t_1 = 32'sd0; Delay11_t_1 <= 32'sd1; Delay11_t_1 = Delay11_t_1 + 32'sd1) begin
      Delay11_reg[Delay11_t_1] = 2'b00;
    end


    for(Delay12_t_1 = 32'sd0; Delay12_t_1 <= 32'sd1; Delay12_t_1 = Delay12_t_1 + 32'sd1) begin
      Delay12_reg[Delay12_t_1] = 3'b000;
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= captureIn;
          Delay4_reg[32'sd3:32'sd1] <= Delay4_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[3];



  assign captureOut = Delay4_out1;

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd3; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd3; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
            Delay7_reg[Delay7_t_0_1] <= Delay7_reg_next[Delay7_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay7_out1 = Delay7_reg[3];
    Delay7_reg_next[0] = modIdx;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd2; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next[Delay7_t_0_0 + 32'sd1] = Delay7_reg[Delay7_t_0_0];
    end

  end



  assign modIdxOut = Delay7_out1;

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        for(Delay8_t_1 = 32'sd0; Delay8_t_1 <= 32'sd3; Delay8_t_1 = Delay8_t_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay8_t_0_1 = 32'sd0; Delay8_t_0_1 <= 32'sd3; Delay8_t_0_1 = Delay8_t_0_1 + 32'sd1) begin
            Delay8_reg[Delay8_t_0_1] <= Delay8_reg_next[Delay8_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay8_out1 = Delay8_reg[3];
    Delay8_reg_next[0] = codIdx;

    for(Delay8_t_0_0 = 32'sd0; Delay8_t_0_0 <= 32'sd2; Delay8_t_0_0 = Delay8_t_0_0 + 32'sd1) begin
      Delay8_reg_next[Delay8_t_0_0 + 32'sd1] = Delay8_reg[Delay8_t_0_0];
    end

  end



  assign codIdxOut = Delay8_out1;

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay3_reg[0] <= fecFrame;
          Delay3_reg[32'sd3:32'sd1] <= Delay3_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[3];



  assign fecFrameOut = Delay3_out1;

  always @(posedge clk)
    begin : Delay9_process
      if (enb) begin
        for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd1; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
          Delay9_reg[Delay9_t_0_0] <= Delay9_reg_next[Delay9_t_0_0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[1];
  assign Delay9_reg_next[0] = modIdx;
  assign Delay9_reg_next[1] = Delay9_reg[0];



  assign prelookup_idx_sat = (Delay9_out1 == 2'b00 ? 2'b00 :
              (Delay9_out1 == 2'b11 ? 2'b11 :
              Delay9_out1));



  assign MaxR_Normal_LUT_1[0] = 16'b1111110100100000;
  assign MaxR_Normal_LUT_1[1] = 16'b0101010001100000;
  assign MaxR_Normal_LUT_1[2] = 16'b0011111101001000;
  assign MaxR_Normal_LUT_1[3] = 16'b0011001010100000;
  assign MaxR_Normal_LUT_out1 = MaxR_Normal_LUT_1[prelookup_idx_sat];



  always @(posedge clk)
    begin : Delay14_process
      if (enb) begin
        for(Delay14_t_0_0 = 32'sd0; Delay14_t_0_0 <= 32'sd1; Delay14_t_0_0 = Delay14_t_0_0 + 32'sd1) begin
          Delay14_reg[Delay14_t_0_0] <= Delay14_reg_next[Delay14_t_0_0];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[1];
  assign Delay14_reg_next[0] = MaxR_Normal_LUT_out1;
  assign Delay14_reg_next[1] = Delay14_reg[0];



  always @(posedge clk)
    begin : Delay10_process
      if (enb) begin
        for(Delay10_t_0_0 = 32'sd0; Delay10_t_0_0 <= 32'sd1; Delay10_t_0_0 = Delay10_t_0_0 + 32'sd1) begin
          Delay10_reg[Delay10_t_0_0] <= Delay10_reg_next[Delay10_t_0_0];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[1];
  assign Delay10_reg_next[0] = modIdx;
  assign Delay10_reg_next[1] = Delay10_reg[0];



  assign prelookup_idx_sat_1 = (Delay10_out1 == 2'b00 ? 2'b00 :
              (Delay10_out1 == 2'b11 ? 2'b11 :
              Delay10_out1));



  assign MaxR_Short_LUT_1[0] = 14'b11111101001000;
  assign MaxR_Short_LUT_1[1] = 14'b01010100011000;
  assign MaxR_Short_LUT_1[2] = 14'b00111111010010;
  assign MaxR_Short_LUT_1[3] = 14'b00110010101000;
  assign MaxR_Short_LUT_out1 = MaxR_Short_LUT_1[prelookup_idx_sat_1];



  always @(posedge clk)
    begin : Delay13_process
      if (enb) begin
        for(Delay13_t_0_0 = 32'sd0; Delay13_t_0_0 <= 32'sd1; Delay13_t_0_0 = Delay13_t_0_0 + 32'sd1) begin
          Delay13_reg[Delay13_t_0_0] <= Delay13_reg_next[Delay13_t_0_0];
        end
      end
    end

  assign Delay13_out1 = Delay13_reg[1];
  assign Delay13_reg_next[0] = MaxR_Short_LUT_out1;
  assign Delay13_reg_next[1] = Delay13_reg[0];



  assign Data_Type_Conversion_out1 = {2'b0, Delay13_out1};



  assign maxR_switch_out1 = (Delay3_out1 == 1'b0 ? Delay14_out1 :
              Data_Type_Conversion_out1);



  assign maxR = maxR_switch_out1;

  always @(posedge clk)
    begin : Delay11_process
      if (enb) begin
        for(Delay11_t_0_0 = 32'sd0; Delay11_t_0_0 <= 32'sd1; Delay11_t_0_0 = Delay11_t_0_0 + 32'sd1) begin
          Delay11_reg[Delay11_t_0_0] <= Delay11_reg_next[Delay11_t_0_0];
        end
      end
    end

  assign Delay11_out1 = Delay11_reg[1];
  assign Delay11_reg_next[0] = modIdx;
  assign Delay11_reg_next[1] = Delay11_reg[0];



  assign prelookup_idx_sat_2 = (Delay11_out1 == 2'b00 ? 2'b00 :
              (Delay11_out1 == 2'b11 ? 2'b11 :
              Delay11_out1));



  assign MaxC_LUT_1[0] = 3'b001;
  assign MaxC_LUT_1[1] = 3'b011;
  assign MaxC_LUT_1[2] = 3'b100;
  assign MaxC_LUT_1[3] = 3'b101;
  assign MaxC_LUT_out1 = MaxC_LUT_1[prelookup_idx_sat_2];



  always @(posedge clk)
    begin : Delay12_process
      if (enb) begin
        for(Delay12_t_0_0 = 32'sd0; Delay12_t_0_0 <= 32'sd1; Delay12_t_0_0 = Delay12_t_0_0 + 32'sd1) begin
          Delay12_reg[Delay12_t_0_0] <= Delay12_reg_next[Delay12_t_0_0];
        end
      end
    end

  assign Delay12_out1 = Delay12_reg[1];
  assign Delay12_reg_next[0] = MaxC_LUT_out1;
  assign Delay12_reg_next[1] = Delay12_reg[0];



  assign maxC = Delay12_out1;

  assign Compare_To_Constant_out1 = Delay7_out1 == 2'b01;



  assign Compare_To_Constant1_out1 = Delay8_out1 == 4'b0100;



  assign Logical_Operator_out1 = Compare_To_Constant_out1 & Compare_To_Constant1_out1;



  assign isMODOCD12 = Logical_Operator_out1;

endmodule  // dvbs2hdlTransmitterCore_nRows_and_nColumns

