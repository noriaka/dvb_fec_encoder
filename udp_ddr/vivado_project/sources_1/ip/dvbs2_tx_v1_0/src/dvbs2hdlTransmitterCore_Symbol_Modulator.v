// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Symbol_Modulator.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Symbol_Modulator
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Symbol Modulator
// Hierarchy Level: 3
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Symbol_Modulator
          (clk,
           reset,
           enb,
           dataIn,
           startIn,
           endIn,
           validIn,
           FECFrame,
           codIdx,
           modIdx,
           MODCOD,
           dataOut_re,
           dataOut_im,
           startOut,
           endOut,
           validOut,
           modIdxOut,
           FECFrameOut,
           MODCODOut);


  input   clk;
  input   reset;
  input   enb;
  input   dataIn;
  input   startIn;
  input   endIn;
  input   validIn;
  input   FECFrame;
  input   [3:0] codIdx;  // ufix4
  input   [1:0] modIdx;  // ufix2
  input   [4:0] MODCOD;  // ufix5
  output  signed [17:0] dataOut_re;  // sfix18_En16
  output  signed [17:0] dataOut_im;  // sfix18_En16
  output  startOut;
  output  endOut;
  output  validOut;
  output  [1:0] modIdxOut;  // ufix2
  output  FECFrameOut;
  output  [4:0] MODCODOut;  // ufix5


  reg  Delay2_out1;
  reg  Delay1_out1;
  reg [1:0] Delay_out1;  // ufix2
  wire [2:0] Data_Type_Conversion_out1;  // ufix3
  reg [3:0] Delay3_out1;  // ufix4
  reg  Delay6_out1;
  wire signed [17:0] DVB_S2_Symbol_Modulator1_out1_re;  // sfix18_En16
  wire signed [17:0] DVB_S2_Symbol_Modulator1_out1_im;  // sfix18_En16
  wire DVB_S2_Symbol_Modulator1_out2;
  reg signed [17:0] Delay15_reg_re [0:1];  // sfix18_En16 [2]
  reg signed [17:0] Delay15_reg_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_reg_next_re [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_reg_next_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_out1_re;  // sfix18_En16
  wire signed [17:0] Delay15_out1_im;  // sfix18_En16
  reg  Delay11_out1;
  reg  [2:0] Delay12_reg;  // ufix1 [3]
  wire Delay12_out1;
  reg  [1:0] Delay17_reg;  // ufix1 [2]
  wire Delay17_out1;
  reg  Delay13_out1;
  reg  [2:0] Delay14_reg;  // ufix1 [3]
  wire Delay14_out1;
  reg  [1:0] Delay18_reg;  // ufix1 [2]
  wire Delay18_out1;
  reg  [1:0] Delay16_reg;  // ufix1 [2]
  wire Delay16_out1;
  reg [1:0] Delay7_reg [0:2];  // ufix2 [3]
  reg [1:0] Delay7_reg_next [0:2];  // ufix2 [3]
  reg [1:0] Delay7_out1;  // ufix2
  reg [1:0] Delay19_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay19_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay19_out1;  // ufix2
  reg  Delay5_out1;
  reg  [2:0] Delay10_reg;  // ufix1 [3]
  wire Delay10_out1;
  reg  [1:0] Delay22_reg;  // ufix1 [2]
  wire Delay22_out1;
  reg [4:0] Delay4_out1;  // ufix5
  reg [4:0] Delay9_reg [0:2];  // ufix5 [3]
  reg [4:0] Delay9_reg_next [0:2];  // ufix5 [3]
  reg [4:0] Delay9_out1;  // ufix5
  reg [4:0] Delay21_reg [0:1];  // ufix5 [2]
  wire [4:0] Delay21_reg_next [0:1];  // ufix5 [2]
  wire [4:0] Delay21_out1;  // ufix5
  reg signed [31:0] Delay15_t_0_0;  // int32
  reg signed [31:0] Delay15_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32
  reg signed [31:0] Delay19_t_0_0;  // int32
  reg signed [31:0] Delay19_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_0_1;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] Delay21_t_0_0;  // int32
  reg signed [31:0] Delay21_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= dataIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= validIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 2'b00;
      end
      else begin
        if (enb) begin
          Delay_out1 <= modIdx;
        end
      end
    end



  assign Data_Type_Conversion_out1 = {1'b0, Delay_out1};



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= codIdx;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= startIn;
        end
      end
    end



  dvbs2hdlTransmitterCore_DVB_S2_Symbol_Modulator1 u_DVB_S2_Symbol_Modulator1 (.clk(clk),
                                                                               .reset(reset),
                                                                               .enb(enb),
                                                                               .in0(Delay2_out1),
                                                                               .in1(Delay1_out1),
                                                                               .in2(Data_Type_Conversion_out1),  // ufix3
                                                                               .in3(Delay3_out1),  // ufix4
                                                                               .in4(Delay6_out1),
                                                                               .out0_re(DVB_S2_Symbol_Modulator1_out1_re),  // sfix18_En16
                                                                               .out0_im(DVB_S2_Symbol_Modulator1_out1_im),  // sfix18_En16
                                                                               .out1(DVB_S2_Symbol_Modulator1_out2)
                                                                               );

  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        for(Delay15_t_1 = 32'sd0; Delay15_t_1 <= 32'sd1; Delay15_t_1 = Delay15_t_1 + 32'sd1) begin
          Delay15_reg_re[Delay15_t_1] <= 18'sb000000000000000000;
          Delay15_reg_im[Delay15_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay15_t_0_0 = 32'sd0; Delay15_t_0_0 <= 32'sd1; Delay15_t_0_0 = Delay15_t_0_0 + 32'sd1) begin
            Delay15_reg_re[Delay15_t_0_0] <= Delay15_reg_next_re[Delay15_t_0_0];
            Delay15_reg_im[Delay15_t_0_0] <= Delay15_reg_next_im[Delay15_t_0_0];
          end
        end
      end
    end

  assign Delay15_out1_re = Delay15_reg_re[1];
  assign Delay15_out1_im = Delay15_reg_im[1];
  assign Delay15_reg_next_re[0] = DVB_S2_Symbol_Modulator1_out1_re;
  assign Delay15_reg_next_im[0] = DVB_S2_Symbol_Modulator1_out1_im;
  assign Delay15_reg_next_re[1] = Delay15_reg_re[0];
  assign Delay15_reg_next_im[1] = Delay15_reg_im[0];



  assign dataOut_re = Delay15_out1_re;

  assign dataOut_im = Delay15_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= startIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay12_reg[0] <= Delay11_out1;
          Delay12_reg[32'sd2:32'sd1] <= Delay12_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay12_out1 = Delay12_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay17_process
      if (reset == 1'b1) begin
        Delay17_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay17_reg[0] <= Delay12_out1;
          Delay17_reg[1] <= Delay17_reg[0];
        end
      end
    end

  assign Delay17_out1 = Delay17_reg[1];



  assign startOut = Delay17_out1;

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= endIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay14_reg[0] <= Delay13_out1;
          Delay14_reg[32'sd2:32'sd1] <= Delay14_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay18_reg[0] <= Delay14_out1;
          Delay18_reg[1] <= Delay18_reg[0];
        end
      end
    end

  assign Delay18_out1 = Delay18_reg[1];



  assign endOut = Delay18_out1;

  always @(posedge clk or posedge reset)
    begin : Delay16_process
      if (reset == 1'b1) begin
        Delay16_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay16_reg[0] <= DVB_S2_Symbol_Modulator1_out2;
          Delay16_reg[1] <= Delay16_reg[0];
        end
      end
    end

  assign Delay16_out1 = Delay16_reg[1];



  assign validOut = Delay16_out1;

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd2; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd2; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
            Delay7_reg[Delay7_t_0_1] <= Delay7_reg_next[Delay7_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay7_out1 = Delay7_reg[2];
    Delay7_reg_next[0] = Delay_out1;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd1; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next[Delay7_t_0_0 + 32'sd1] = Delay7_reg[Delay7_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay19_process
      if (reset == 1'b1) begin
        for(Delay19_t_1 = 32'sd0; Delay19_t_1 <= 32'sd1; Delay19_t_1 = Delay19_t_1 + 32'sd1) begin
          Delay19_reg[Delay19_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay19_t_0_0 = 32'sd0; Delay19_t_0_0 <= 32'sd1; Delay19_t_0_0 = Delay19_t_0_0 + 32'sd1) begin
            Delay19_reg[Delay19_t_0_0] <= Delay19_reg_next[Delay19_t_0_0];
          end
        end
      end
    end

  assign Delay19_out1 = Delay19_reg[1];
  assign Delay19_reg_next[0] = Delay7_out1;
  assign Delay19_reg_next[1] = Delay19_reg[0];



  assign modIdxOut = Delay19_out1;

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= FECFrame;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= Delay5_out1;
          Delay10_reg[32'sd2:32'sd1] <= Delay10_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay22_process
      if (reset == 1'b1) begin
        Delay22_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay22_reg[0] <= Delay10_out1;
          Delay22_reg[1] <= Delay22_reg[0];
        end
      end
    end

  assign Delay22_out1 = Delay22_reg[1];



  assign FECFrameOut = Delay22_out1;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 5'b00000;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= MODCOD;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd2; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_1] <= 5'b00000;
        end
      end
      else begin
        if (enb) begin
          for(Delay9_t_0_1 = 32'sd0; Delay9_t_0_1 <= 32'sd2; Delay9_t_0_1 = Delay9_t_0_1 + 32'sd1) begin
            Delay9_reg[Delay9_t_0_1] <= Delay9_reg_next[Delay9_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay9_out1 = Delay9_reg[2];
    Delay9_reg_next[0] = Delay4_out1;

    for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd1; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
      Delay9_reg_next[Delay9_t_0_0 + 32'sd1] = Delay9_reg[Delay9_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay21_process
      if (reset == 1'b1) begin
        for(Delay21_t_1 = 32'sd0; Delay21_t_1 <= 32'sd1; Delay21_t_1 = Delay21_t_1 + 32'sd1) begin
          Delay21_reg[Delay21_t_1] <= 5'b00000;
        end
      end
      else begin
        if (enb) begin
          for(Delay21_t_0_0 = 32'sd0; Delay21_t_0_0 <= 32'sd1; Delay21_t_0_0 = Delay21_t_0_0 + 32'sd1) begin
            Delay21_reg[Delay21_t_0_0] <= Delay21_reg_next[Delay21_t_0_0];
          end
        end
      end
    end

  assign Delay21_out1 = Delay21_reg[1];
  assign Delay21_reg_next[0] = Delay9_out1;
  assign Delay21_reg_next[1] = Delay21_reg[0];



  assign MODCODOut = Delay21_out1;

endmodule  // dvbs2hdlTransmitterCore_Symbol_Modulator

