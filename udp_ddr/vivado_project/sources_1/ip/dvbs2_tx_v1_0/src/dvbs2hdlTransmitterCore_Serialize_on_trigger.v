// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Serialize_on_trigger.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Serialize_on_trigger
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/PL Frame Generator/PL Header Generator/PL Header Bits Generator/PLSC 
// Generator/Serialize on trigge
// Hierarchy Level: 7
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Serialize_on_trigger
          (clk,
           reset,
           enb_1_16_0,
           data_0,
           data_1,
           data_2,
           data_3,
           data_4,
           data_5,
           data_6,
           data_7,
           data_8,
           data_9,
           data_10,
           data_11,
           data_12,
           data_13,
           data_14,
           data_15,
           data_16,
           data_17,
           data_18,
           data_19,
           data_20,
           data_21,
           data_22,
           data_23,
           data_24,
           data_25,
           data_26,
           data_27,
           data_28,
           data_29,
           data_30,
           data_31,
           trigger,
           dataOut,
           validOut,
           startOut);


  input   clk;
  input   reset;
  input   enb_1_16_0;
  input   data_0;  // ufix1
  input   data_1;  // ufix1
  input   data_2;  // ufix1
  input   data_3;  // ufix1
  input   data_4;  // ufix1
  input   data_5;  // ufix1
  input   data_6;  // ufix1
  input   data_7;  // ufix1
  input   data_8;  // ufix1
  input   data_9;  // ufix1
  input   data_10;  // ufix1
  input   data_11;  // ufix1
  input   data_12;  // ufix1
  input   data_13;  // ufix1
  input   data_14;  // ufix1
  input   data_15;  // ufix1
  input   data_16;  // ufix1
  input   data_17;  // ufix1
  input   data_18;  // ufix1
  input   data_19;  // ufix1
  input   data_20;  // ufix1
  input   data_21;  // ufix1
  input   data_22;  // ufix1
  input   data_23;  // ufix1
  input   data_24;  // ufix1
  input   data_25;  // ufix1
  input   data_26;  // ufix1
  input   data_27;  // ufix1
  input   data_28;  // ufix1
  input   data_29;  // ufix1
  input   data_30;  // ufix1
  input   data_31;  // ufix1
  input   trigger;
  output  dataOut;  // ufix1
  output  validOut;
  output  startOut;


  reg  trigger_1;
  wire stateControl_1;
  reg  stateControl_2;
  wire enb_1_16_0_gated;
  wire [31:0] data;  // ufix1 [32]
  reg  dataOut_1;  // ufix1
  reg  validOut_1;
  reg  startOut_1;
  reg [4:0] count;  // ufix5
  reg  countActive;
  reg [4:0] count_next;  // ufix5
  reg  countActive_next;
  wire dataOut_bypass;  // ufix1
  reg  dataOut_last_value;  // ufix1
  wire validOut_bypass;
  reg  validOut_last_value;
  wire startOut_bypass;
  reg  startOut_last_value;
  reg [5:0] add_temp;  // ufix6
  reg [5:0] t_0;  // ufix6


  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        trigger_1 <= 1'b0;
      end
      else begin
        if (enb_1_16_0) begin
          trigger_1 <= trigger;
        end
      end
    end



  assign stateControl_1 = 1'b1;



  always @(posedge clk or posedge reset)
    begin : delayMatch1_process
      if (reset == 1'b1) begin
        stateControl_2 <= 1'b0;
      end
      else begin
        if (enb_1_16_0) begin
          stateControl_2 <= stateControl_1;
        end
      end
    end



  assign enb_1_16_0_gated = stateControl_2 && enb_1_16_0;

  assign data[0] = data_0;
  assign data[1] = data_1;
  assign data[2] = data_2;
  assign data[3] = data_3;
  assign data[4] = data_4;
  assign data[5] = data_5;
  assign data[6] = data_6;
  assign data[7] = data_7;
  assign data[8] = data_8;
  assign data[9] = data_9;
  assign data[10] = data_10;
  assign data[11] = data_11;
  assign data[12] = data_12;
  assign data[13] = data_13;
  assign data[14] = data_14;
  assign data[15] = data_15;
  assign data[16] = data_16;
  assign data[17] = data_17;
  assign data[18] = data_18;
  assign data[19] = data_19;
  assign data[20] = data_20;
  assign data[21] = data_21;
  assign data[22] = data_22;
  assign data[23] = data_23;
  assign data[24] = data_24;
  assign data[25] = data_25;
  assign data[26] = data_26;
  assign data[27] = data_27;
  assign data[28] = data_28;
  assign data[29] = data_29;
  assign data[30] = data_30;
  assign data[31] = data_31;

  always @(posedge clk or posedge reset)
    begin : Serialize_on_trigger_process
      if (reset == 1'b1) begin
        count <= 5'b00000;
        countActive <= 1'b0;
      end
      else begin
        if (enb_1_16_0_gated) begin
          count <= count_next;
          countActive <= countActive_next;
        end
      end
    end

  always @* begin
    count_next = count;
    countActive_next = countActive;
    startOut_1 = (count == 5'b00000) && countActive;
    if (countActive) begin
      if (count == 5'b11111) begin
        count_next = 5'b00000;
        countActive_next = 1'b0;
      end
      else begin
        count_next = count + 5'b00001;
      end
    end
    if (trigger_1) begin
      countActive_next = 1'b1;
    end
    t_0 = {1'b0, count};
    add_temp = t_0 + 6'b000001;
    // dataOut_1 = data[$signed({1'b0, add_temp}) - 32'sd1];
    dataOut_1 = data[({1'b0, add_temp}) - 32'sd1];
    validOut_1 = countActive;
  end



  always @(posedge clk or posedge reset)
    begin : out0_bypass_process
      if (reset == 1'b1) begin
        dataOut_last_value <= 1'b0;
      end
      else begin
        if (enb_1_16_0_gated) begin
          dataOut_last_value <= dataOut_bypass;
        end
      end
    end



  assign dataOut_bypass = (stateControl_2 == 1'b0 ? dataOut_last_value :
              dataOut_1);



  assign dataOut = dataOut_bypass;

  always @(posedge clk or posedge reset)
    begin : out1_bypass_process
      if (reset == 1'b1) begin
        validOut_last_value <= 1'b0;
      end
      else begin
        if (enb_1_16_0_gated) begin
          validOut_last_value <= validOut_bypass;
        end
      end
    end



  assign validOut_bypass = (stateControl_2 == 1'b0 ? validOut_last_value :
              validOut_1);



  assign validOut = validOut_bypass;

  always @(posedge clk or posedge reset)
    begin : out2_bypass_process
      if (reset == 1'b1) begin
        startOut_last_value <= 1'b0;
      end
      else begin
        if (enb_1_16_0_gated) begin
          startOut_last_value <= startOut_bypass;
        end
      end
    end



  assign startOut_bypass = (stateControl_2 == 1'b0 ? startOut_last_value :
              startOut_1);



  assign startOut = startOut_bypass;

endmodule  // dvbs2hdlTransmitterCore_Serialize_on_trigger

