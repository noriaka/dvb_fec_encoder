// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Control_Logic.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Control_Logic
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator/Read Offset 
// Address/Read Offset Address Signals Generator/Control Logi
// Hierarchy Level: 8
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Control_Logic
          (clk,
           reset,
           enb,
           vMaxR,
           chkwrAddrEnd,
           vMaxC,
           vModCodIs12,
           wrAddr,
           wrEnb,
           modIdx,
           curCorROut,
           maxRorCOut,
           curRorCOut,
           startOut,
           endOut,
           readValid);


  input   clk;
  input   reset;
  input   enb;
  input   [15:0] vMaxR;  // uint16
  input   [15:0] chkwrAddrEnd;  // uint16
  input   [2:0] vMaxC;  // ufix3
  input   vModCodIs12;
  input   [15:0] wrAddr;  // uint16
  input   wrEnb;
  input   [1:0] modIdx;  // ufix2
  output  [2:0] curCorROut;  // ufix3
  output  [15:0] maxRorCOut;  // uint16
  output  [15:0] curRorCOut;  // uint16
  output  startOut;
  output  endOut;
  output  readValid;


  reg [2:0] curCorROut_1;  // ufix3
  reg [15:0] maxRorCOut_1;  // uint16
  reg [15:0] curRorCOut_1;  // uint16
  reg  modcodIs12Out;
  reg  startOut_1;
  reg  endOut_1;
  reg  readValid_1;
  reg [2:0] cnt8;  // ufix3
  reg  rdEnb_not_empty;
  reg  rdEnbOld;
  reg  startOutReg_1;
  reg [15:0] curR;  // uint16
  reg [2:0] curC;  // ufix3
  reg [2:0] framCnt;  // ufix3
  reg [2:0] curCorROutReg;  // ufix3
  reg [15:0] maxRorCOutReg;  // uint16
  reg [15:0] curRorCOutReg;  // uint16
  reg  modcodIs12OutReg;
  reg [1:0] wrModIdxReg;  // ufix2
  reg [1:0] rdModIdxReg;  // ufix2
  reg [2:0] countXOutof8;  // ufix3
  reg  rdEnbActive;
  reg  rdEnb_not_empty_next;
  reg  rdEnbOld_next;
  reg  startOutReg_next;
  reg [15:0] curR_next;  // uint16
  reg [2:0] curC_next;  // ufix3
  reg [2:0] framCnt_next;  // ufix3
  reg [2:0] curCorROutReg_next;  // ufix3
  reg [15:0] maxRorCOutReg_next;  // uint16
  reg [15:0] curRorCOutReg_next;  // uint16
  reg  modcodIs12OutReg_next;
  reg [1:0] wrModIdxReg_next;  // ufix2
  reg [1:0] rdModIdxReg_next;  // ufix2
  reg [2:0] countXOutof8_next;  // ufix3
  reg  rdEnbActive_next;
  reg  startOutReg;
  reg  rdEnb;
  reg  rdEnbOld_temp;
  reg [15:0] curR_temp;  // uint16
  reg [2:0] curC_temp;  // ufix3
  reg [2:0] framCnt_temp;  // ufix3
  reg [1:0] wrModIdxReg_temp;  // ufix2
  reg [1:0] rdModIdxReg_temp;  // ufix2
  reg [2:0] countXOutof8_temp;  // ufix3
  reg  rdEnbActive_temp;
  reg signed [4:0] sub_temp;  // sfix5
  reg [3:0] cast;  // ufix4
  reg [3:0] add_temp;  // ufix4
  reg signed [16:0] sub_temp_0;  // sfix17
  reg [15:0] cast_0;  // uint16
  reg [16:0] add_temp_0;  // ufix17
  reg [3:0] add_temp_1;  // ufix4
  reg [3:0] t_0;  // ufix4
  reg [2:0] t_1;  // ufix3
  reg [3:0] t_2;  // ufix4
  reg signed [4:0] t_3;  // sfix5
  reg [3:0] t_4;  // ufix4
  reg signed [16:0] t_5;  // sfix17
  reg [16:0] t_6;  // ufix17
  reg [3:0] t_7;  // ufix4


  always @(posedge clk or posedge reset)
    begin : Control_Logic_process
      if (reset == 1'b1) begin
        rdEnb_not_empty <= 1'b0;
      end
      else begin
        if (enb) begin
          rdEnb_not_empty <= rdEnb_not_empty_next;
          rdEnbOld <= rdEnbOld_next;
          startOutReg_1 <= startOutReg_next;
          curR <= curR_next;
          curC <= curC_next;
          framCnt <= framCnt_next;
          curCorROutReg <= curCorROutReg_next;
          maxRorCOutReg <= maxRorCOutReg_next;
          curRorCOutReg <= curRorCOutReg_next;
          modcodIs12OutReg <= modcodIs12OutReg_next;
          wrModIdxReg <= wrModIdxReg_next;
          rdModIdxReg <= rdModIdxReg_next;
          countXOutof8 <= countXOutof8_next;
          rdEnbActive <= rdEnbActive_next;
        end
      end
    end

  always @(chkwrAddrEnd, countXOutof8, curC, curCorROutReg, curR, curRorCOutReg, framCnt,
       maxRorCOutReg, modIdx, modcodIs12OutReg, rdEnbActive, rdEnbOld,
       rdEnb_not_empty, rdModIdxReg, startOutReg_1, vMaxC, vMaxR, vModCodIs12,
       wrAddr, wrEnb, wrModIdxReg) begin
    sub_temp = 5'sb00000;
    add_temp = 4'b0000;
    sub_temp_0 = 17'sb00000000000000000;
    add_temp_0 = 17'b00000000000000000;
    add_temp_1 = 4'b0000;
    t_2 = 4'b0000;
    t_3 = 5'sb00000;
    t_0 = 4'b0000;
    t_5 = 17'sb00000000000000000;
    t_1 = 3'b000;
    t_7 = 4'b0000;
    t_6 = 17'b00000000000000000;
    t_4 = 4'b0000;
    cast = 4'b0000;
    cast_0 = 16'd0;
    rdEnbOld_temp = rdEnbOld;
    startOut_1 = startOutReg_1;
    curR_temp = curR;
    curC_temp = curC;
    framCnt_temp = framCnt;
    curCorROut_1 = curCorROutReg;
    maxRorCOut_1 = maxRorCOutReg;
    curRorCOut_1 = curRorCOutReg;
    modcodIs12Out = modcodIs12OutReg;
    wrModIdxReg_temp = wrModIdxReg;
    rdModIdxReg_temp = rdModIdxReg;
    countXOutof8_temp = countXOutof8;
    rdEnbActive_temp = rdEnbActive;
    rdEnb_not_empty_next = rdEnb_not_empty;
    if ( ! rdEnb_not_empty) begin
      rdEnb_not_empty_next = 1'b1;
      rdEnbOld_temp = 1'b0;
      curR_temp = 16'd0;
      curC_temp = 3'b000;
      startOut_1 = 1'b0;
      framCnt_temp = 3'b000;
      // XorY => Store X for Interleaver and Y for Deinterleaver
      curCorROut_1 = 3'b000;
      maxRorCOut_1 = vMaxR;
      curRorCOut_1 = 16'd0;
      modcodIs12Out = vModCodIs12;
      wrModIdxReg_temp = 2'b00;
      rdModIdxReg_temp = 2'b00;
      countXOutof8_temp = 3'b000;
      rdEnbActive_temp = 1'b0;
    end
    endOut_1 = 1'b0;
    if (rdEnbOld_temp) begin
      t_2 = {1'b0, vMaxC};
      t_3 = {1'b0, t_2};
      sub_temp = t_3 - 5'sb00001;
      if (sub_temp[4] == 1'b1) begin
        cast = 4'b0000;
      end
      else begin
        cast = sub_temp[3:0];
      end
      t_0 = {1'b0, curC_temp};
      if (t_0 == cast) begin
        curC_temp = 3'b000;
        t_5 = {1'b0, vMaxR};
        sub_temp_0 = t_5 - 17'sb00000000000000001;
        if (sub_temp_0[16] == 1'b1) begin
          cast_0 = 16'b0000000000000000;
        end
        else begin
          cast_0 = sub_temp_0[15:0];
        end
        if (curR_temp == cast_0) begin
          curR_temp = 16'd0;
          framCnt_temp = framCnt_temp - 3'b001;
          if (framCnt_temp == 3'b000) begin
            rdEnbActive_temp = 1'b0;
            curC_temp = 3'b000;
            curR_temp = 16'd0;
          end
          endOut_1 = 1'b1;
        end
        else begin
          t_6 = {1'b0, curR_temp};
          add_temp_0 = t_6 + 17'b00000000000000001;
          if (add_temp_0[16] != 1'b0) begin
            curR_temp = 16'b1111111111111111;
          end
          else begin
            curR_temp = add_temp_0[15:0];
          end
        end
      end
      else begin
        t_4 = {1'b0, curC_temp};
        add_temp = t_4 + 4'b0001;
        if (add_temp[3] != 1'b0) begin
          curC_temp = 3'b111;
        end
        else begin
          curC_temp = add_temp[2:0];
        end
      end
    end
    if ((rdEnbActive_temp && ((curR_temp != 16'd0) || (curC_temp != 3'b000))) || (rdEnbActive_temp && (countXOutof8_temp == 3'b000))) begin
      t_1 = {1'b0, rdModIdxReg_temp};
      rdEnb =  ! (countXOutof8_temp > (t_1 + 3'b001));
    end
    else begin
      rdEnb = 1'b0;
    end
    if (countXOutof8_temp == 3'b111) begin
      countXOutof8_next = 3'b000;
    end
    else begin
      t_7 = {1'b0, countXOutof8_temp};
      add_temp_1 = t_7 + 4'b0001;
      if (add_temp_1[3] != 1'b0) begin
        countXOutof8_next = 3'b111;
      end
      else begin
        countXOutof8_next = add_temp_1[2:0];
      end
    end
    if (vModCodIs12 && (curC_temp == 3'b000)) begin
      curCorROutReg_next = 3'b010;
    end
    else if (vModCodIs12 && (curC_temp == 3'b010)) begin
      curCorROutReg_next = 3'b000;
    end
    else begin
      curCorROutReg_next = curC_temp;
    end
    startOutReg = (rdEnb && (curR_temp == 16'd0)) && (curC_temp == 3'b000);
    if (wrEnb && (wrAddr == chkwrAddrEnd)) begin
      framCnt_temp = framCnt_temp + 3'b001;
      rdEnbActive_temp = 1'b1;
      wrModIdxReg_temp = modIdx;
    end
    if (startOutReg) begin
      rdModIdxReg_temp = wrModIdxReg_temp;
    end
    readValid_1 = rdEnbOld_temp;
    cnt8 = countXOutof8_temp;
    rdEnbOld_next = rdEnb;
    startOutReg_next = startOutReg;
    curR_next = curR_temp;
    curC_next = curC_temp;
    framCnt_next = framCnt_temp;
    maxRorCOutReg_next = vMaxR;
    curRorCOutReg_next = curR_temp;
    modcodIs12OutReg_next = vModCodIs12;
    wrModIdxReg_next = wrModIdxReg_temp;
    rdModIdxReg_next = rdModIdxReg_temp;
    rdEnbActive_next = rdEnbActive_temp;
  end



  assign curCorROut = curCorROut_1;

  assign maxRorCOut = maxRorCOut_1;

  assign curRorCOut = curRorCOut_1;

  assign startOut = startOut_1;

  assign endOut = endOut_1;

  assign readValid = readValid_1;

endmodule  // dvbs2hdlTransmitterCore_Control_Logic

