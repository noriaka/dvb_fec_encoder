// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_RAM_Address_Generator.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_RAM_Address_Generator
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator
// Hierarchy Level: 5
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_RAM_Address_Generator
          (clk,
           reset,
           enb,
           dataIn,
           validIn,
           paramValid,
           fecframeIn,
           modIdxIn,
           codIdxIn,
           dataOut,
           writeAddr,
           writeEnable,
           readAddr,
           readValid,
           readEnd,
           readStart,
           codIdx,
           fecframe,
           modidx);


  input   clk;
  input   reset;
  input   enb;
  input   dataIn;
  input   validIn;
  input   paramValid;
  input   fecframeIn;
  input   [1:0] modIdxIn;  // ufix2
  input   [3:0] codIdxIn;  // ufix4
  output  dataOut;
  output  [16:0] writeAddr;  // ufix17
  output  writeEnable;
  output  [17:0] readAddr;  // ufix18
  output  readValid;
  output  readEnd;
  output  readStart;
  output  [3:0] codIdx;  // ufix4
  output  fecframe;
  output  [1:0] modidx;  // ufix2


  reg  [3:0] Delay14_reg;  // ufix1 [4]
  wire Delay14_out1;
  reg  Delay8_out1;
  reg  [3:0] Delay18_reg;  // ufix1 [4]
  wire Delay18_out1;
  reg  [1:0] Delay22_reg;  // ufix1 [2]
  wire Delay22_out1;
  reg  [7:0] Delay55_reg;  // ufix1 [8]
  wire Delay55_out1;
  reg  Delay37_out1;
  reg  [2:0] Delay47_reg;  // ufix1 [3]
  wire Delay47_out1;
  reg  [3:0] Delay52_reg;  // ufix1 [4]
  wire Delay52_out1;
  reg  [3:0] Delay10_reg;  // ufix1 [4]
  wire Delay10_out1;
  wire [16:0] count_step;  // ufix17
  wire [16:0] count_from;  // ufix17
  reg [16:0] Write_Base_plus_Offset_Address_out1;  // ufix17
  wire [16:0] count;  // ufix17
  wire need_to_wrap;
  wire [16:0] count_value;  // ufix17
  wire [16:0] count_1;  // ufix17
  reg [16:0] Delay7_out1;  // ufix17
  reg [16:0] Delay17_reg [0:3];  // ufix17 [4]
  reg [16:0] Delay17_reg_next [0:3];  // ufix17 [4]
  reg [16:0] Delay17_out1;  // ufix17
  reg [16:0] Delay21_reg [0:1];  // ufix17 [2]
  wire [16:0] Delay21_reg_next [0:1];  // ufix17 [2]
  wire [16:0] Delay21_out1;  // ufix17
  reg [16:0] Delay54_reg [0:7];  // ufix17 [8]
  reg [16:0] Delay54_reg_next [0:7];  // ufix17 [8]
  reg [16:0] Delay54_out1;  // ufix17
  reg [16:0] Delay36_out1;  // ufix17
  reg [16:0] Delay46_reg [0:2];  // ufix17 [3]
  reg [16:0] Delay46_reg_next [0:2];  // ufix17 [3]
  reg [16:0] Delay46_out1;  // ufix17
  reg [16:0] Delay51_reg [0:3];  // ufix17 [4]
  reg [16:0] Delay51_reg_next [0:3];  // ufix17 [4]
  reg [16:0] Delay51_out1;  // ufix17
  reg  Delay6_out1;
  reg  [3:0] Delay16_reg;  // ufix1 [4]
  wire Delay16_out1;
  reg  [1:0] Delay20_reg;  // ufix1 [2]
  wire Delay20_out1;
  reg  [7:0] Delay53_reg;  // ufix1 [8]
  wire Delay53_out1;
  reg  Delay35_out1;
  reg  [2:0] Delay45_reg;  // ufix1 [3]
  wire Delay45_out1;
  reg  [3:0] Delay50_reg;  // ufix1 [4]
  wire Delay50_out1;
  reg  [3:0] Delay13_reg;  // ufix1 [4]
  wire Delay13_out1;
  reg  Delay1_out1;
  reg [1:0] Delay12_reg [0:3];  // ufix2 [4]
  reg [1:0] Delay12_reg_next [0:3];  // ufix2 [4]
  reg [1:0] Delay12_out1;  // ufix2
  reg [1:0] Delay2_out1;  // ufix2
  reg [3:0] Delay11_reg [0:3];  // ufix4 [4]
  reg [3:0] Delay11_reg_next [0:3];  // ufix4 [4]
  reg [3:0] Delay11_out1;  // ufix4
  reg [3:0] Delay3_out1;  // ufix4
  reg  [3:0] Delay9_reg;  // ufix1 [4]
  wire Delay9_out1;
  reg  Delay4_out1;
  wire nRows_and_nColumns_out1;
  wire [1:0] nRows_and_nColumns_out2;  // ufix2
  wire [3:0] nRows_and_nColumns_out3;  // ufix4
  wire nRows_and_nColumns_out4;
  wire [15:0] nRows_and_nColumns_out5;  // uint16
  wire [2:0] nRows_and_nColumns_out6;  // ufix3
  wire nRows_and_nColumns_out7;
  reg [15:0] Delay25_reg [0:1];  // ufix16 [2]
  wire [15:0] Delay25_reg_next [0:1];  // ufix16 [2]
  wire [15:0] Delay25_out1;  // uint16
  reg [2:0] Delay24_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay24_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay24_out1;  // ufix3
  reg  [1:0] Delay23_reg;  // ufix1 [2]
  wire Delay23_out1;
  wire [15:0] Write_Offset_Address_out1;  // uint16
  reg [15:0] Delay5_out1;  // uint16
  reg [15:0] Delay15_reg [0:3];  // ufix16 [4]
  reg [15:0] Delay15_reg_next [0:3];  // ufix16 [4]
  reg [15:0] Delay15_out1;  // uint16
  reg [15:0] Delay19_reg [0:1];  // ufix16 [2]
  wire [15:0] Delay19_reg_next [0:1];  // ufix16 [2]
  wire [15:0] Delay19_out1;  // uint16
  reg [1:0] Delay28_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay28_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay28_out1;  // ufix2
  wire [16:0] Read_Offset_Address_out1;  // ufix17
  wire Read_Offset_Address_out2;
  wire Read_Offset_Address_out3;
  wire Read_Offset_Address_out4;
  reg [16:0] Delay31_out1;  // ufix17
  reg [16:0] Delay41_reg [0:2];  // ufix17 [3]
  reg [16:0] Delay41_reg_next [0:2];  // ufix17 [3]
  reg [16:0] Delay41_out1;  // ufix17
  reg  Delay32_out1;
  reg  [2:0] Delay42_reg;  // ufix1 [3]
  wire Delay42_out1;
  reg  Delay33_out1;
  reg  [2:0] Delay43_reg;  // ufix1 [3]
  wire Delay43_out1;
  reg  Delay34_out1;
  reg  [2:0] Delay44_reg;  // ufix1 [3]
  wire Delay44_out1;
  wire [17:0] Generate_and_Add_Read_Base_Address_out1;  // ufix18
  wire Generate_and_Add_Read_Base_Address_out2;
  wire Generate_and_Add_Read_Base_Address_out3;
  wire Generate_and_Add_Read_Base_Address_out4;
  reg  [1:0] Delay29_reg;  // ufix1 [2]
  wire Delay29_out1;
  reg  [7:0] Delay56_reg;  // ufix1 [8]
  wire Delay56_out1;
  reg  Delay30_out1;
  reg [1:0] Delay57_reg [0:7];  // ufix2 [8]
  reg [1:0] Delay57_reg_next [0:7];  // ufix2 [8]
  reg [1:0] Delay57_out1;  // ufix2
  reg [1:0] Delay40_out1;  // ufix2
  reg [3:0] Delay27_reg [0:1];  // ufix4 [2]
  wire [3:0] Delay27_reg_next [0:1];  // ufix4 [2]
  wire [3:0] Delay27_out1;  // ufix4
  reg [3:0] Delay58_reg [0:7];  // ufix4 [8]
  reg [3:0] Delay58_reg_next [0:7];  // ufix4 [8]
  reg [3:0] Delay58_out1;  // ufix4
  reg [3:0] Delay39_out1;  // ufix4
  reg  [1:0] Delay26_reg;  // ufix1 [2]
  wire Delay26_out1;
  reg  [7:0] Delay59_reg;  // ufix1 [8]
  wire Delay59_out1;
  reg  Delay38_out1;
  wire [3:0] Parameter_Store_FIFO_out1;  // ufix4
  wire Parameter_Store_FIFO_out2;
  wire [1:0] Parameter_Store_FIFO_out3;  // ufix2
  reg [3:0] Delay49_reg [0:3];  // ufix4 [4]
  reg [3:0] Delay49_reg_next [0:3];  // ufix4 [4]
  reg [3:0] Delay49_out1;  // ufix4
  reg  [3:0] Delay48_reg;  // ufix1 [4]
  wire Delay48_out1;
  reg [1:0] Delay60_reg [0:3];  // ufix2 [4]
  reg [1:0] Delay60_reg_next [0:3];  // ufix2 [4]
  reg [1:0] Delay60_out1;  // ufix2
  reg signed [31:0] Delay17_t_0_0;  // int32
  reg signed [31:0] Delay17_t_0_1;  // int32
  reg signed [31:0] Delay17_t_1;  // int32
  reg signed [31:0] Delay21_t_0_0;  // int32
  reg signed [31:0] Delay21_t_1;  // int32
  reg signed [31:0] Delay54_t_0_0;  // int32
  reg signed [31:0] Delay54_t_0_1;  // int32
  reg signed [31:0] Delay54_t_1;  // int32
  reg signed [31:0] Delay46_t_0_0;  // int32
  reg signed [31:0] Delay46_t_0_1;  // int32
  reg signed [31:0] Delay46_t_1;  // int32
  reg signed [31:0] Delay51_t_0_0;  // int32
  reg signed [31:0] Delay51_t_0_1;  // int32
  reg signed [31:0] Delay51_t_1;  // int32
  reg signed [31:0] Delay12_t_0_0;  // int32
  reg signed [31:0] Delay12_t_0_1;  // int32
  reg signed [31:0] Delay12_t_1;  // int32
  reg signed [31:0] Delay11_t_0_0;  // int32
  reg signed [31:0] Delay11_t_0_1;  // int32
  reg signed [31:0] Delay11_t_1;  // int32
  reg signed [31:0] Delay25_t_0_0;  // int32
  reg signed [31:0] Delay25_t_1;  // int32
  reg signed [31:0] Delay24_t_0_0;  // int32
  reg signed [31:0] Delay24_t_1;  // int32
  reg signed [31:0] Delay15_t_0_0;  // int32
  reg signed [31:0] Delay15_t_0_1;  // int32
  reg signed [31:0] Delay15_t_1;  // int32
  reg signed [31:0] Delay19_t_0_0;  // int32
  reg signed [31:0] Delay19_t_1;  // int32
  reg signed [31:0] Delay28_t_0_0;  // int32
  reg signed [31:0] Delay28_t_1;  // int32
  reg signed [31:0] Delay41_t_0_0;  // int32
  reg signed [31:0] Delay41_t_0_1;  // int32
  reg signed [31:0] Delay41_t_1;  // int32
  reg signed [31:0] Delay57_t_0_0;  // int32
  reg signed [31:0] Delay57_t_0_1;  // int32
  reg signed [31:0] Delay57_t_1;  // int32
  reg signed [31:0] Delay27_t_0_0;  // int32
  reg signed [31:0] Delay27_t_1;  // int32
  reg signed [31:0] Delay58_t_0_0;  // int32
  reg signed [31:0] Delay58_t_0_1;  // int32
  reg signed [31:0] Delay58_t_1;  // int32
  reg signed [31:0] Delay49_t_0_0;  // int32
  reg signed [31:0] Delay49_t_0_1;  // int32
  reg signed [31:0] Delay49_t_1;  // int32
  reg signed [31:0] Delay60_t_0_0;  // int32
  reg signed [31:0] Delay60_t_0_1;  // int32
  reg signed [31:0] Delay60_t_1;  // int32

  // Read Ports
  // Write Ports


  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay14_reg[0] <= dataIn;
          Delay14_reg[32'sd3:32'sd1] <= Delay14_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= Delay14_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay18_reg[0] <= Delay8_out1;
          Delay18_reg[32'sd3:32'sd1] <= Delay18_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay18_out1 = Delay18_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay22_process
      if (reset == 1'b1) begin
        Delay22_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay22_reg[0] <= Delay18_out1;
          Delay22_reg[1] <= Delay22_reg[0];
        end
      end
    end

  assign Delay22_out1 = Delay22_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay55_process
      if (reset == 1'b1) begin
        Delay55_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          Delay55_reg[0] <= Delay22_out1;
          Delay55_reg[32'sd7:32'sd1] <= Delay55_reg[32'sd6:32'sd0];
        end
      end
    end

  assign Delay55_out1 = Delay55_reg[7];



  always @(posedge clk or posedge reset)
    begin : Delay37_process
      if (reset == 1'b1) begin
        Delay37_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay37_out1 <= Delay55_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay47_process
      if (reset == 1'b1) begin
        Delay47_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay47_reg[0] <= Delay37_out1;
          Delay47_reg[32'sd2:32'sd1] <= Delay47_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay47_out1 = Delay47_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay52_process
      if (reset == 1'b1) begin
        Delay52_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay52_reg[0] <= Delay47_out1;
          Delay52_reg[32'sd3:32'sd1] <= Delay52_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay52_out1 = Delay52_reg[3];



  assign dataOut = Delay52_out1;

  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay10_reg[0] <= validIn;
          Delay10_reg[32'sd3:32'sd1] <= Delay10_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[3];



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 129599
  assign count_step = 17'b00000000000000001;



  assign count_from = 17'b00000000000000000;



  assign count = Write_Base_plus_Offset_Address_out1 + count_step;



  assign need_to_wrap = Write_Base_plus_Offset_Address_out1 == 17'b11111101000111111;



  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);



  assign count_1 = (Delay10_out1 == 1'b0 ? Write_Base_plus_Offset_Address_out1 :
              count_value);



  always @(posedge clk or posedge reset)
    begin : Write_Base_plus_Offset_Address_process
      if (reset == 1'b1) begin
        Write_Base_plus_Offset_Address_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Write_Base_plus_Offset_Address_out1 <= count_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Write_Base_plus_Offset_Address_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay17_process
      if (reset == 1'b1) begin
        for(Delay17_t_1 = 32'sd0; Delay17_t_1 <= 32'sd3; Delay17_t_1 = Delay17_t_1 + 32'sd1) begin
          Delay17_reg[Delay17_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay17_t_0_1 = 32'sd0; Delay17_t_0_1 <= 32'sd3; Delay17_t_0_1 = Delay17_t_0_1 + 32'sd1) begin
            Delay17_reg[Delay17_t_0_1] <= Delay17_reg_next[Delay17_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay17_out1 = Delay17_reg[3];
    Delay17_reg_next[0] = Delay7_out1;

    for(Delay17_t_0_0 = 32'sd0; Delay17_t_0_0 <= 32'sd2; Delay17_t_0_0 = Delay17_t_0_0 + 32'sd1) begin
      Delay17_reg_next[Delay17_t_0_0 + 32'sd1] = Delay17_reg[Delay17_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay21_process
      if (reset == 1'b1) begin
        for(Delay21_t_1 = 32'sd0; Delay21_t_1 <= 32'sd1; Delay21_t_1 = Delay21_t_1 + 32'sd1) begin
          Delay21_reg[Delay21_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay21_t_0_0 = 32'sd0; Delay21_t_0_0 <= 32'sd1; Delay21_t_0_0 = Delay21_t_0_0 + 32'sd1) begin
            Delay21_reg[Delay21_t_0_0] <= Delay21_reg_next[Delay21_t_0_0];
          end
        end
      end
    end

  assign Delay21_out1 = Delay21_reg[1];
  assign Delay21_reg_next[0] = Delay17_out1;
  assign Delay21_reg_next[1] = Delay21_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay54_process
      if (reset == 1'b1) begin
        for(Delay54_t_1 = 32'sd0; Delay54_t_1 <= 32'sd7; Delay54_t_1 = Delay54_t_1 + 32'sd1) begin
          Delay54_reg[Delay54_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay54_t_0_1 = 32'sd0; Delay54_t_0_1 <= 32'sd7; Delay54_t_0_1 = Delay54_t_0_1 + 32'sd1) begin
            Delay54_reg[Delay54_t_0_1] <= Delay54_reg_next[Delay54_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay54_out1 = Delay54_reg[7];
    Delay54_reg_next[0] = Delay21_out1;

    for(Delay54_t_0_0 = 32'sd0; Delay54_t_0_0 <= 32'sd6; Delay54_t_0_0 = Delay54_t_0_0 + 32'sd1) begin
      Delay54_reg_next[Delay54_t_0_0 + 32'sd1] = Delay54_reg[Delay54_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay36_process
      if (reset == 1'b1) begin
        Delay36_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay36_out1 <= Delay54_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay46_process
      if (reset == 1'b1) begin
        for(Delay46_t_1 = 32'sd0; Delay46_t_1 <= 32'sd2; Delay46_t_1 = Delay46_t_1 + 32'sd1) begin
          Delay46_reg[Delay46_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay46_t_0_1 = 32'sd0; Delay46_t_0_1 <= 32'sd2; Delay46_t_0_1 = Delay46_t_0_1 + 32'sd1) begin
            Delay46_reg[Delay46_t_0_1] <= Delay46_reg_next[Delay46_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay46_out1 = Delay46_reg[2];
    Delay46_reg_next[0] = Delay36_out1;

    for(Delay46_t_0_0 = 32'sd0; Delay46_t_0_0 <= 32'sd1; Delay46_t_0_0 = Delay46_t_0_0 + 32'sd1) begin
      Delay46_reg_next[Delay46_t_0_0 + 32'sd1] = Delay46_reg[Delay46_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay51_process
      if (reset == 1'b1) begin
        for(Delay51_t_1 = 32'sd0; Delay51_t_1 <= 32'sd3; Delay51_t_1 = Delay51_t_1 + 32'sd1) begin
          Delay51_reg[Delay51_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay51_t_0_1 = 32'sd0; Delay51_t_0_1 <= 32'sd3; Delay51_t_0_1 = Delay51_t_0_1 + 32'sd1) begin
            Delay51_reg[Delay51_t_0_1] <= Delay51_reg_next[Delay51_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay51_out1 = Delay51_reg[3];
    Delay51_reg_next[0] = Delay46_out1;

    for(Delay51_t_0_0 = 32'sd0; Delay51_t_0_0 <= 32'sd2; Delay51_t_0_0 = Delay51_t_0_0 + 32'sd1) begin
      Delay51_reg_next[Delay51_t_0_0 + 32'sd1] = Delay51_reg[Delay51_t_0_0];
    end

  end



  assign writeAddr = Delay51_out1;

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Delay10_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay16_process
      if (reset == 1'b1) begin
        Delay16_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay16_reg[0] <= Delay6_out1;
          Delay16_reg[32'sd3:32'sd1] <= Delay16_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay16_out1 = Delay16_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay20_process
      if (reset == 1'b1) begin
        Delay20_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay20_reg[0] <= Delay16_out1;
          Delay20_reg[1] <= Delay20_reg[0];
        end
      end
    end

  assign Delay20_out1 = Delay20_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay53_process
      if (reset == 1'b1) begin
        Delay53_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          Delay53_reg[0] <= Delay20_out1;
          Delay53_reg[32'sd7:32'sd1] <= Delay53_reg[32'sd6:32'sd0];
        end
      end
    end

  assign Delay53_out1 = Delay53_reg[7];



  always @(posedge clk or posedge reset)
    begin : Delay35_process
      if (reset == 1'b1) begin
        Delay35_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay35_out1 <= Delay53_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay45_process
      if (reset == 1'b1) begin
        Delay45_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay45_reg[0] <= Delay35_out1;
          Delay45_reg[32'sd2:32'sd1] <= Delay45_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay45_out1 = Delay45_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay50_process
      if (reset == 1'b1) begin
        Delay50_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay50_reg[0] <= Delay45_out1;
          Delay50_reg[32'sd3:32'sd1] <= Delay50_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay50_out1 = Delay50_reg[3];



  assign writeEnable = Delay50_out1;

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay13_reg[0] <= paramValid;
          Delay13_reg[32'sd3:32'sd1] <= Delay13_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay13_out1 = Delay13_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= Delay13_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        for(Delay12_t_1 = 32'sd0; Delay12_t_1 <= 32'sd3; Delay12_t_1 = Delay12_t_1 + 32'sd1) begin
          Delay12_reg[Delay12_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay12_t_0_1 = 32'sd0; Delay12_t_0_1 <= 32'sd3; Delay12_t_0_1 = Delay12_t_0_1 + 32'sd1) begin
            Delay12_reg[Delay12_t_0_1] <= Delay12_reg_next[Delay12_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay12_out1 = Delay12_reg[3];
    Delay12_reg_next[0] = modIdxIn;

    for(Delay12_t_0_0 = 32'sd0; Delay12_t_0_0 <= 32'sd2; Delay12_t_0_0 = Delay12_t_0_0 + 32'sd1) begin
      Delay12_reg_next[Delay12_t_0_0 + 32'sd1] = Delay12_reg[Delay12_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 2'b00;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Delay12_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        for(Delay11_t_1 = 32'sd0; Delay11_t_1 <= 32'sd3; Delay11_t_1 = Delay11_t_1 + 32'sd1) begin
          Delay11_reg[Delay11_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay11_t_0_1 = 32'sd0; Delay11_t_0_1 <= 32'sd3; Delay11_t_0_1 = Delay11_t_0_1 + 32'sd1) begin
            Delay11_reg[Delay11_t_0_1] <= Delay11_reg_next[Delay11_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay11_out1 = Delay11_reg[3];
    Delay11_reg_next[0] = codIdxIn;

    for(Delay11_t_0_0 = 32'sd0; Delay11_t_0_0 <= 32'sd2; Delay11_t_0_0 = Delay11_t_0_0 + 32'sd1) begin
      Delay11_reg_next[Delay11_t_0_0 + 32'sd1] = Delay11_reg[Delay11_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Delay11_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay9_reg[0] <= fecframeIn;
          Delay9_reg[32'sd3:32'sd1] <= Delay9_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[3];



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= Delay9_out1;
        end
      end
    end



  dvbs2hdlTransmitterCore_nRows_and_nColumns u_nRows_and_nColumns (.clk(clk),
                                                                   .reset(reset),
                                                                   .enb(enb),
                                                                   .captureIn(Delay1_out1),
                                                                   .modIdx(Delay2_out1),  // ufix2
                                                                   .codIdx(Delay3_out1),  // ufix4
                                                                   .fecFrame(Delay4_out1),
                                                                   .captureOut(nRows_and_nColumns_out1),
                                                                   .modIdxOut(nRows_and_nColumns_out2),  // ufix2
                                                                   .codIdxOut(nRows_and_nColumns_out3),  // ufix4
                                                                   .fecFrameOut(nRows_and_nColumns_out4),
                                                                   .maxR(nRows_and_nColumns_out5),  // uint16
                                                                   .maxC(nRows_and_nColumns_out6),  // ufix3
                                                                   .isMODOCD12(nRows_and_nColumns_out7)
                                                                   );

  always @(posedge clk or posedge reset)
    begin : Delay25_process
      if (reset == 1'b1) begin
        for(Delay25_t_1 = 32'sd0; Delay25_t_1 <= 32'sd1; Delay25_t_1 = Delay25_t_1 + 32'sd1) begin
          Delay25_reg[Delay25_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay25_t_0_0 = 32'sd0; Delay25_t_0_0 <= 32'sd1; Delay25_t_0_0 = Delay25_t_0_0 + 32'sd1) begin
            Delay25_reg[Delay25_t_0_0] <= Delay25_reg_next[Delay25_t_0_0];
          end
        end
      end
    end

  assign Delay25_out1 = Delay25_reg[1];
  assign Delay25_reg_next[0] = nRows_and_nColumns_out5;
  assign Delay25_reg_next[1] = Delay25_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay24_process
      if (reset == 1'b1) begin
        for(Delay24_t_1 = 32'sd0; Delay24_t_1 <= 32'sd1; Delay24_t_1 = Delay24_t_1 + 32'sd1) begin
          Delay24_reg[Delay24_t_1] <= 3'b000;
        end
      end
      else begin
        if (enb) begin
          for(Delay24_t_0_0 = 32'sd0; Delay24_t_0_0 <= 32'sd1; Delay24_t_0_0 = Delay24_t_0_0 + 32'sd1) begin
            Delay24_reg[Delay24_t_0_0] <= Delay24_reg_next[Delay24_t_0_0];
          end
        end
      end
    end

  assign Delay24_out1 = Delay24_reg[1];
  assign Delay24_reg_next[0] = nRows_and_nColumns_out6;
  assign Delay24_reg_next[1] = Delay24_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay23_process
      if (reset == 1'b1) begin
        Delay23_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay23_reg[0] <= nRows_and_nColumns_out7;
          Delay23_reg[1] <= Delay23_reg[0];
        end
      end
    end

  assign Delay23_out1 = Delay23_reg[1];



  dvbs2hdlTransmitterCore_Write_Offset_Address u_Write_Offset_Address (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb(enb),
                                                                       .fecframe(fecframeIn),
                                                                       .enb_1(validIn),
                                                                       .addr(Write_Offset_Address_out1)  // uint16
                                                                       );

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Write_Offset_Address_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        for(Delay15_t_1 = 32'sd0; Delay15_t_1 <= 32'sd3; Delay15_t_1 = Delay15_t_1 + 32'sd1) begin
          Delay15_reg[Delay15_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay15_t_0_1 = 32'sd0; Delay15_t_0_1 <= 32'sd3; Delay15_t_0_1 = Delay15_t_0_1 + 32'sd1) begin
            Delay15_reg[Delay15_t_0_1] <= Delay15_reg_next[Delay15_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay15_out1 = Delay15_reg[3];
    Delay15_reg_next[0] = Delay5_out1;

    for(Delay15_t_0_0 = 32'sd0; Delay15_t_0_0 <= 32'sd2; Delay15_t_0_0 = Delay15_t_0_0 + 32'sd1) begin
      Delay15_reg_next[Delay15_t_0_0 + 32'sd1] = Delay15_reg[Delay15_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay19_process
      if (reset == 1'b1) begin
        for(Delay19_t_1 = 32'sd0; Delay19_t_1 <= 32'sd1; Delay19_t_1 = Delay19_t_1 + 32'sd1) begin
          Delay19_reg[Delay19_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay19_t_0_0 = 32'sd0; Delay19_t_0_0 <= 32'sd1; Delay19_t_0_0 = Delay19_t_0_0 + 32'sd1) begin
            Delay19_reg[Delay19_t_0_0] <= Delay19_reg_next[Delay19_t_0_0];
          end
        end
      end
    end

  assign Delay19_out1 = Delay19_reg[1];
  assign Delay19_reg_next[0] = Delay15_out1;
  assign Delay19_reg_next[1] = Delay19_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay28_process
      if (reset == 1'b1) begin
        for(Delay28_t_1 = 32'sd0; Delay28_t_1 <= 32'sd1; Delay28_t_1 = Delay28_t_1 + 32'sd1) begin
          Delay28_reg[Delay28_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay28_t_0_0 = 32'sd0; Delay28_t_0_0 <= 32'sd1; Delay28_t_0_0 = Delay28_t_0_0 + 32'sd1) begin
            Delay28_reg[Delay28_t_0_0] <= Delay28_reg_next[Delay28_t_0_0];
          end
        end
      end
    end

  assign Delay28_out1 = Delay28_reg[1];
  assign Delay28_reg_next[0] = nRows_and_nColumns_out2;
  assign Delay28_reg_next[1] = Delay28_reg[0];



  dvbs2hdlTransmitterCore_Read_Offset_Address u_Read_Offset_Address (.clk(clk),
                                                                     .reset(reset),
                                                                     .enb(enb),
                                                                     .maxR(Delay25_out1),  // uint16
                                                                     .maxC(Delay24_out1),  // ufix3
                                                                     .modcodIs12(Delay23_out1),
                                                                     .wrAddr(Delay19_out1),  // uint16
                                                                     .wrEnb(Delay20_out1),
                                                                     .modIdx(Delay28_out1),  // ufix2
                                                                     .readAddr(Read_Offset_Address_out1),  // ufix17
                                                                     .readValid(Read_Offset_Address_out2),
                                                                     .startOut(Read_Offset_Address_out3),
                                                                     .endOut(Read_Offset_Address_out4)
                                                                     );

  always @(posedge clk or posedge reset)
    begin : Delay31_process
      if (reset == 1'b1) begin
        Delay31_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay31_out1 <= Read_Offset_Address_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay41_process
      if (reset == 1'b1) begin
        for(Delay41_t_1 = 32'sd0; Delay41_t_1 <= 32'sd2; Delay41_t_1 = Delay41_t_1 + 32'sd1) begin
          Delay41_reg[Delay41_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay41_t_0_1 = 32'sd0; Delay41_t_0_1 <= 32'sd2; Delay41_t_0_1 = Delay41_t_0_1 + 32'sd1) begin
            Delay41_reg[Delay41_t_0_1] <= Delay41_reg_next[Delay41_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay41_out1 = Delay41_reg[2];
    Delay41_reg_next[0] = Delay31_out1;

    for(Delay41_t_0_0 = 32'sd0; Delay41_t_0_0 <= 32'sd1; Delay41_t_0_0 = Delay41_t_0_0 + 32'sd1) begin
      Delay41_reg_next[Delay41_t_0_0 + 32'sd1] = Delay41_reg[Delay41_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay32_process
      if (reset == 1'b1) begin
        Delay32_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay32_out1 <= Read_Offset_Address_out2;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay42_process
      if (reset == 1'b1) begin
        Delay42_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay42_reg[0] <= Delay32_out1;
          Delay42_reg[32'sd2:32'sd1] <= Delay42_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay42_out1 = Delay42_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay33_process
      if (reset == 1'b1) begin
        Delay33_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay33_out1 <= Read_Offset_Address_out3;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay43_process
      if (reset == 1'b1) begin
        Delay43_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay43_reg[0] <= Delay33_out1;
          Delay43_reg[32'sd2:32'sd1] <= Delay43_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay43_out1 = Delay43_reg[2];



  always @(posedge clk or posedge reset)
    begin : Delay34_process
      if (reset == 1'b1) begin
        Delay34_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay34_out1 <= Read_Offset_Address_out4;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay44_process
      if (reset == 1'b1) begin
        Delay44_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay44_reg[0] <= Delay34_out1;
          Delay44_reg[32'sd2:32'sd1] <= Delay44_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay44_out1 = Delay44_reg[2];



  dvbs2hdlTransmitterCore_Generate_and_Add_Read_Base_Address u_Generate_and_Add_Read_Base_Address (.clk(clk),
                                                                                                   .reset(reset),
                                                                                                   .enb(enb),
                                                                                                   .readAddrIn(Delay41_out1),  // ufix17
                                                                                                   .readValidIn(Delay42_out1),
                                                                                                   .startIn(Delay43_out1),
                                                                                                   .endIn(Delay44_out1),
                                                                                                   .readAddrOut(Generate_and_Add_Read_Base_Address_out1),  // ufix18
                                                                                                   .readValidOut(Generate_and_Add_Read_Base_Address_out2),
                                                                                                   .readStartOut(Generate_and_Add_Read_Base_Address_out3),
                                                                                                   .readEndOut(Generate_and_Add_Read_Base_Address_out4)
                                                                                                   );

  assign readAddr = Generate_and_Add_Read_Base_Address_out1;

  assign readValid = Generate_and_Add_Read_Base_Address_out2;

  assign readEnd = Generate_and_Add_Read_Base_Address_out4;

  assign readStart = Generate_and_Add_Read_Base_Address_out3;

  always @(posedge clk or posedge reset)
    begin : Delay29_process
      if (reset == 1'b1) begin
        Delay29_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay29_reg[0] <= nRows_and_nColumns_out1;
          Delay29_reg[1] <= Delay29_reg[0];
        end
      end
    end

  assign Delay29_out1 = Delay29_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay56_process
      if (reset == 1'b1) begin
        Delay56_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          Delay56_reg[0] <= Delay29_out1;
          Delay56_reg[32'sd7:32'sd1] <= Delay56_reg[32'sd6:32'sd0];
        end
      end
    end

  assign Delay56_out1 = Delay56_reg[7];



  always @(posedge clk or posedge reset)
    begin : Delay30_process
      if (reset == 1'b1) begin
        Delay30_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay30_out1 <= Delay56_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay57_process
      if (reset == 1'b1) begin
        for(Delay57_t_1 = 32'sd0; Delay57_t_1 <= 32'sd7; Delay57_t_1 = Delay57_t_1 + 32'sd1) begin
          Delay57_reg[Delay57_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay57_t_0_1 = 32'sd0; Delay57_t_0_1 <= 32'sd7; Delay57_t_0_1 = Delay57_t_0_1 + 32'sd1) begin
            Delay57_reg[Delay57_t_0_1] <= Delay57_reg_next[Delay57_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay57_out1 = Delay57_reg[7];
    Delay57_reg_next[0] = Delay28_out1;

    for(Delay57_t_0_0 = 32'sd0; Delay57_t_0_0 <= 32'sd6; Delay57_t_0_0 = Delay57_t_0_0 + 32'sd1) begin
      Delay57_reg_next[Delay57_t_0_0 + 32'sd1] = Delay57_reg[Delay57_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay40_process
      if (reset == 1'b1) begin
        Delay40_out1 <= 2'b00;
      end
      else begin
        if (enb) begin
          Delay40_out1 <= Delay57_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay27_process
      if (reset == 1'b1) begin
        for(Delay27_t_1 = 32'sd0; Delay27_t_1 <= 32'sd1; Delay27_t_1 = Delay27_t_1 + 32'sd1) begin
          Delay27_reg[Delay27_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay27_t_0_0 = 32'sd0; Delay27_t_0_0 <= 32'sd1; Delay27_t_0_0 = Delay27_t_0_0 + 32'sd1) begin
            Delay27_reg[Delay27_t_0_0] <= Delay27_reg_next[Delay27_t_0_0];
          end
        end
      end
    end

  assign Delay27_out1 = Delay27_reg[1];
  assign Delay27_reg_next[0] = nRows_and_nColumns_out3;
  assign Delay27_reg_next[1] = Delay27_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay58_process
      if (reset == 1'b1) begin
        for(Delay58_t_1 = 32'sd0; Delay58_t_1 <= 32'sd7; Delay58_t_1 = Delay58_t_1 + 32'sd1) begin
          Delay58_reg[Delay58_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay58_t_0_1 = 32'sd0; Delay58_t_0_1 <= 32'sd7; Delay58_t_0_1 = Delay58_t_0_1 + 32'sd1) begin
            Delay58_reg[Delay58_t_0_1] <= Delay58_reg_next[Delay58_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay58_out1 = Delay58_reg[7];
    Delay58_reg_next[0] = Delay27_out1;

    for(Delay58_t_0_0 = 32'sd0; Delay58_t_0_0 <= 32'sd6; Delay58_t_0_0 = Delay58_t_0_0 + 32'sd1) begin
      Delay58_reg_next[Delay58_t_0_0 + 32'sd1] = Delay58_reg[Delay58_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay39_process
      if (reset == 1'b1) begin
        Delay39_out1 <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay39_out1 <= Delay58_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay26_process
      if (reset == 1'b1) begin
        Delay26_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay26_reg[0] <= nRows_and_nColumns_out4;
          Delay26_reg[1] <= Delay26_reg[0];
        end
      end
    end

  assign Delay26_out1 = Delay26_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay59_process
      if (reset == 1'b1) begin
        Delay59_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          Delay59_reg[0] <= Delay26_out1;
          Delay59_reg[32'sd7:32'sd1] <= Delay59_reg[32'sd6:32'sd0];
        end
      end
    end

  assign Delay59_out1 = Delay59_reg[7];



  always @(posedge clk or posedge reset)
    begin : Delay38_process
      if (reset == 1'b1) begin
        Delay38_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay38_out1 <= Delay59_out1;
        end
      end
    end



  dvbs2hdlTransmitterCore_Parameter_Store_FIFO u_Parameter_Store_FIFO (.clk(clk),
                                                                       .reset(reset),
                                                                       .enb(enb),
                                                                       .writeVal(Delay30_out1),
                                                                       .modIdxOut(Delay40_out1),  // ufix2
                                                                       .codIdxOut(Delay39_out1),  // ufix4
                                                                       .fecFrameOut(Delay38_out1),
                                                                       .readVal(Delay33_out1),
                                                                       .codIdx(Parameter_Store_FIFO_out1),  // ufix4
                                                                       .fecframe(Parameter_Store_FIFO_out2),
                                                                       .modIdx(Parameter_Store_FIFO_out3)  // ufix2
                                                                       );

  always @(posedge clk or posedge reset)
    begin : Delay49_process
      if (reset == 1'b1) begin
        for(Delay49_t_1 = 32'sd0; Delay49_t_1 <= 32'sd3; Delay49_t_1 = Delay49_t_1 + 32'sd1) begin
          Delay49_reg[Delay49_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay49_t_0_1 = 32'sd0; Delay49_t_0_1 <= 32'sd3; Delay49_t_0_1 = Delay49_t_0_1 + 32'sd1) begin
            Delay49_reg[Delay49_t_0_1] <= Delay49_reg_next[Delay49_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay49_out1 = Delay49_reg[3];
    Delay49_reg_next[0] = Parameter_Store_FIFO_out1;

    for(Delay49_t_0_0 = 32'sd0; Delay49_t_0_0 <= 32'sd2; Delay49_t_0_0 = Delay49_t_0_0 + 32'sd1) begin
      Delay49_reg_next[Delay49_t_0_0 + 32'sd1] = Delay49_reg[Delay49_t_0_0];
    end

  end



  assign codIdx = Delay49_out1;

  always @(posedge clk or posedge reset)
    begin : Delay48_process
      if (reset == 1'b1) begin
        Delay48_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          Delay48_reg[0] <= Parameter_Store_FIFO_out2;
          Delay48_reg[32'sd3:32'sd1] <= Delay48_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay48_out1 = Delay48_reg[3];



  assign fecframe = Delay48_out1;

  always @(posedge clk or posedge reset)
    begin : Delay60_process
      if (reset == 1'b1) begin
        for(Delay60_t_1 = 32'sd0; Delay60_t_1 <= 32'sd3; Delay60_t_1 = Delay60_t_1 + 32'sd1) begin
          Delay60_reg[Delay60_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay60_t_0_1 = 32'sd0; Delay60_t_0_1 <= 32'sd3; Delay60_t_0_1 = Delay60_t_0_1 + 32'sd1) begin
            Delay60_reg[Delay60_t_0_1] <= Delay60_reg_next[Delay60_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay60_out1 = Delay60_reg[3];
    Delay60_reg_next[0] = Parameter_Store_FIFO_out3;

    for(Delay60_t_0_0 = 32'sd0; Delay60_t_0_0 <= 32'sd2; Delay60_t_0_0 = Delay60_t_0_0 + 32'sd1) begin
      Delay60_reg_next[Delay60_t_0_0 + 32'sd1] = Delay60_reg[Delay60_t_0_0];
    end

  end



  assign modidx = Delay60_out1;

endmodule  // dvbs2hdlTransmitterCore_RAM_Address_Generator

