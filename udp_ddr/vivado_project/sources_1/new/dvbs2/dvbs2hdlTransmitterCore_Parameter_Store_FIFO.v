// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Parameter_Store_FIFO.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Parameter_Store_FIFO
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator/Parameter 
// Store FIF
// Hierarchy Level: 6
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Parameter_Store_FIFO
          (clk,
           reset,
           enb,
           writeVal,
           modIdxOut,
           codIdxOut,
           fecFrameOut,
           readVal,
           codIdx,
           fecframe,
           modIdx);


  input   clk;
  input   reset;
  input   enb;
  input   writeVal;
  input   [1:0] modIdxOut;  // ufix2
  input   [3:0] codIdxOut;  // ufix4
  input   fecFrameOut;
  input   readVal;
  output  [3:0] codIdx;  // ufix4
  output  fecframe;
  output  [1:0] modIdx;  // ufix2


  reg [3:0] Delay6_out1;  // ufix4
  reg [3:0] Delay5_reg [0:1];  // ufix4 [2]
  wire [3:0] Delay5_reg_next [0:1];  // ufix4 [2]
  wire [3:0] Delay5_out1;  // ufix4
  wire [2:0] count_step;  // ufix3
  wire [2:0] count_from;  // ufix3
  reg [2:0] WriteVal_Address_out1;  // ufix3
  wire [2:0] count;  // ufix3
  wire need_to_wrap;
  wire [2:0] count_value;  // ufix3
  wire [2:0] count_1;  // ufix3
  reg [2:0] Delay8_out1;  // ufix3
  reg [2:0] Delay7_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay7_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay7_out1;  // ufix3
  reg  Delay9_out1;
  reg  [1:0] Delay15_reg;  // ufix1 [2]
  wire Delay15_out1;
  wire [2:0] count_step_1;  // ufix3
  wire [2:0] count_from_1;  // ufix3
  reg [2:0] ReadVal_Address_out1;  // ufix3
  wire [2:0] count_2;  // ufix3
  wire need_to_wrap_1;
  wire [2:0] count_value_1;  // ufix3
  wire [2:0] count_3;  // ufix3
  reg [2:0] Delay10_out1;  // ufix3
  reg [2:0] Delay16_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay16_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay16_out1;  // ufix3
  wire [3:0] cod_Idx_FIFO_out1;  // ufix4
  reg [3:0] Delay3_reg [0:1];  // ufix4 [2]
  wire [3:0] Delay3_reg_next [0:1];  // ufix4 [2]
  wire [3:0] Delay3_out1;  // ufix4
  reg [3:0] Delay1_reg [0:2];  // ufix4 [3]
  reg [3:0] Delay1_reg_next [0:2];  // ufix4 [3]
  reg [3:0] Delay1_out1;  // ufix4
  reg  Delay11_out1;
  reg  [1:0] Delay17_reg;  // ufix1 [2]
  wire Delay17_out1;
  reg [2:0] Delay12_out1;  // ufix3
  reg [2:0] Delay18_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay18_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay18_out1;  // ufix3
  reg  Delay13_out1;
  reg  [1:0] Delay19_reg;  // ufix1 [2]
  wire Delay19_out1;
  reg [2:0] Delay14_out1;  // ufix3
  reg [2:0] Delay20_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay20_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay20_out1;  // ufix3
  wire Fec_Frame_FIFO_out1;
  reg  [1:0] Delay4_reg;  // ufix1 [2]
  wire Delay4_out1;
  reg  [2:0] Delay2_reg;  // ufix1 [3]
  wire Delay2_out1;
  reg [1:0] Delay22_out1;  // ufix2
  reg [1:0] Delay24_reg [0:1];  // ufix2 [2]
  wire [1:0] Delay24_reg_next [0:1];  // ufix2 [2]
  wire [1:0] Delay24_out1;  // ufix2
  reg [2:0] Delay21_out1;  // ufix3
  reg [2:0] Delay26_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay26_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay26_out1;  // ufix3
  reg  Delay23_out1;
  reg  [1:0] Delay28_reg;  // ufix1 [2]
  wire Delay28_out1;
  reg [2:0] Delay25_out1;  // ufix3
  reg [2:0] Delay29_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay29_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay29_out1;  // ufix3
  wire [1:0] Simple_Dual_Port_RAM2_out1;  // ufix2
  reg [1:0] Delay27_reg [0:4];  // ufix2 [5]
  reg [1:0] Delay27_reg_next [0:4];  // ufix2 [5]
  reg [1:0] Delay27_out1;  // ufix2
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_1;  // int32
  reg signed [31:0] Delay16_t_0_0;  // int32
  reg signed [31:0] Delay16_t_1;  // int32
  reg signed [31:0] Delay3_t_0_0;  // int32
  reg signed [31:0] Delay3_t_1;  // int32
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_0_1;  // int32
  reg signed [31:0] Delay1_t_1;  // int32
  reg signed [31:0] Delay18_t_0_0;  // int32
  reg signed [31:0] Delay18_t_1;  // int32
  reg signed [31:0] Delay20_t_0_0;  // int32
  reg signed [31:0] Delay20_t_1;  // int32
  reg signed [31:0] Delay24_t_0_0;  // int32
  reg signed [31:0] Delay24_t_1;  // int32
  reg signed [31:0] Delay26_t_0_0;  // int32
  reg signed [31:0] Delay26_t_1;  // int32
  reg signed [31:0] Delay29_t_0_0;  // int32
  reg signed [31:0] Delay29_t_1;  // int32
  reg signed [31:0] Delay27_t_0_0;  // int32
  reg signed [31:0] Delay27_t_0_1;  // int32
  reg signed [31:0] Delay27_t_1;  // int32

  initial begin

    for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd1; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
      Delay5_reg[Delay5_t_1] = 4'b0000;
    end


    for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd1; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
      Delay7_reg[Delay7_t_1] = 3'b000;
    end

    Delay15_reg = {2{1'b0}};

    for(Delay16_t_1 = 32'sd0; Delay16_t_1 <= 32'sd1; Delay16_t_1 = Delay16_t_1 + 32'sd1) begin
      Delay16_reg[Delay16_t_1] = 3'b000;
    end


    for(Delay3_t_1 = 32'sd0; Delay3_t_1 <= 32'sd1; Delay3_t_1 = Delay3_t_1 + 32'sd1) begin
      Delay3_reg[Delay3_t_1] = 4'b0000;
    end

    Delay17_reg = {2{1'b0}};

    for(Delay18_t_1 = 32'sd0; Delay18_t_1 <= 32'sd1; Delay18_t_1 = Delay18_t_1 + 32'sd1) begin
      Delay18_reg[Delay18_t_1] = 3'b000;
    end

    Delay19_reg = {2{1'b0}};

    for(Delay20_t_1 = 32'sd0; Delay20_t_1 <= 32'sd1; Delay20_t_1 = Delay20_t_1 + 32'sd1) begin
      Delay20_reg[Delay20_t_1] = 3'b000;
    end

    Delay4_reg = {2{1'b0}};

    for(Delay24_t_1 = 32'sd0; Delay24_t_1 <= 32'sd1; Delay24_t_1 = Delay24_t_1 + 32'sd1) begin
      Delay24_reg[Delay24_t_1] = 2'b00;
    end


    for(Delay26_t_1 = 32'sd0; Delay26_t_1 <= 32'sd1; Delay26_t_1 = Delay26_t_1 + 32'sd1) begin
      Delay26_reg[Delay26_t_1] = 3'b000;
    end

    Delay28_reg = {2{1'b0}};

    for(Delay29_t_1 = 32'sd0; Delay29_t_1 <= 32'sd1; Delay29_t_1 = Delay29_t_1 + 32'sd1) begin
      Delay29_reg[Delay29_t_1] = 3'b000;
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 4'b0000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= codIdxOut;
        end
      end
    end



  always @(posedge clk)
    begin : Delay5_process
      if (enb) begin
        for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd1; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
          Delay5_reg[Delay5_t_0_0] <= Delay5_reg_next[Delay5_t_0_0];
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[1];
  assign Delay5_reg_next[0] = Delay6_out1;
  assign Delay5_reg_next[1] = Delay5_reg[0];



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  assign count_step = 3'b001;



  assign count_from = 3'b000;



  assign count = WriteVal_Address_out1 + count_step;



  assign need_to_wrap = WriteVal_Address_out1 == 3'b111;



  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);



  assign count_1 = (writeVal == 1'b0 ? WriteVal_Address_out1 :
              count_value);



  always @(posedge clk or posedge reset)
    begin : WriteVal_Address_process
      if (reset == 1'b1) begin
        WriteVal_Address_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          WriteVal_Address_out1 <= count_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= WriteVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay7_process
      if (enb) begin
        for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd1; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
          Delay7_reg[Delay7_t_0_0] <= Delay7_reg_next[Delay7_t_0_0];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[1];
  assign Delay7_reg_next[0] = Delay8_out1;
  assign Delay7_reg_next[1] = Delay7_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= writeVal;
        end
      end
    end



  always @(posedge clk)
    begin : Delay15_process
      if (enb) begin
        Delay15_reg[0] <= Delay9_out1;
        Delay15_reg[1] <= Delay15_reg[0];
      end
    end

  assign Delay15_out1 = Delay15_reg[1];



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  assign count_step_1 = 3'b001;



  assign count_from_1 = 3'b000;



  assign count_2 = ReadVal_Address_out1 + count_step_1;



  assign need_to_wrap_1 = ReadVal_Address_out1 == 3'b111;



  assign count_value_1 = (need_to_wrap_1 == 1'b0 ? count_2 :
              count_from_1);



  assign count_3 = (readVal == 1'b0 ? ReadVal_Address_out1 :
              count_value_1);



  always @(posedge clk or posedge reset)
    begin : ReadVal_Address_process
      if (reset == 1'b1) begin
        ReadVal_Address_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          ReadVal_Address_out1 <= count_3;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay10_out1 <= ReadVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay16_process
      if (enb) begin
        for(Delay16_t_0_0 = 32'sd0; Delay16_t_0_0 <= 32'sd1; Delay16_t_0_0 = Delay16_t_0_0 + 32'sd1) begin
          Delay16_reg[Delay16_t_0_0] <= Delay16_reg_next[Delay16_t_0_0];
        end
      end
    end

  assign Delay16_out1 = Delay16_reg[1];
  assign Delay16_reg_next[0] = Delay10_out1;
  assign Delay16_reg_next[1] = Delay16_reg[0];



  dvbs2hdlTransmitterCore_SimpleDualPortRAM_generic_block #(.AddrWidth(3),
                                                            .DataWidth(4)
                                                            )
                                                          u_cod_Idx_FIFO (.clk(clk),
                                                                          .enb(enb),
                                                                          .wr_din(Delay5_out1),
                                                                          .wr_addr(Delay7_out1),
                                                                          .wr_en(Delay15_out1),
                                                                          .rd_addr(Delay16_out1),
                                                                          .dout(cod_Idx_FIFO_out1)
                                                                          );

  always @(posedge clk)
    begin : Delay3_process
      if (enb) begin
        for(Delay3_t_0_0 = 32'sd0; Delay3_t_0_0 <= 32'sd1; Delay3_t_0_0 = Delay3_t_0_0 + 32'sd1) begin
          Delay3_reg[Delay3_t_0_0] <= Delay3_reg_next[Delay3_t_0_0];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[1];
  assign Delay3_reg_next[0] = cod_Idx_FIFO_out1;
  assign Delay3_reg_next[1] = Delay3_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd2; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg[Delay1_t_1] <= 4'b0000;
        end
      end
      else begin
        if (enb) begin
          for(Delay1_t_0_1 = 32'sd0; Delay1_t_0_1 <= 32'sd2; Delay1_t_0_1 = Delay1_t_0_1 + 32'sd1) begin
            Delay1_reg[Delay1_t_0_1] <= Delay1_reg_next[Delay1_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay1_out1 = Delay1_reg[2];
    Delay1_reg_next[0] = Delay3_out1;

    for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
      Delay1_reg_next[Delay1_t_0_0 + 32'sd1] = Delay1_reg[Delay1_t_0_0];
    end

  end



  assign codIdx = Delay1_out1;

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= fecFrameOut;
        end
      end
    end



  always @(posedge clk)
    begin : Delay17_process
      if (enb) begin
        Delay17_reg[0] <= Delay11_out1;
        Delay17_reg[1] <= Delay17_reg[0];
      end
    end

  assign Delay17_out1 = Delay17_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= WriteVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay18_process
      if (enb) begin
        for(Delay18_t_0_0 = 32'sd0; Delay18_t_0_0 <= 32'sd1; Delay18_t_0_0 = Delay18_t_0_0 + 32'sd1) begin
          Delay18_reg[Delay18_t_0_0] <= Delay18_reg_next[Delay18_t_0_0];
        end
      end
    end

  assign Delay18_out1 = Delay18_reg[1];
  assign Delay18_reg_next[0] = Delay12_out1;
  assign Delay18_reg_next[1] = Delay18_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= writeVal;
        end
      end
    end



  always @(posedge clk)
    begin : Delay19_process
      if (enb) begin
        Delay19_reg[0] <= Delay13_out1;
        Delay19_reg[1] <= Delay19_reg[0];
      end
    end

  assign Delay19_out1 = Delay19_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay14_out1 <= ReadVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay20_process
      if (enb) begin
        for(Delay20_t_0_0 = 32'sd0; Delay20_t_0_0 <= 32'sd1; Delay20_t_0_0 = Delay20_t_0_0 + 32'sd1) begin
          Delay20_reg[Delay20_t_0_0] <= Delay20_reg_next[Delay20_t_0_0];
        end
      end
    end

  assign Delay20_out1 = Delay20_reg[1];
  assign Delay20_reg_next[0] = Delay14_out1;
  assign Delay20_reg_next[1] = Delay20_reg[0];



  dvbs2hdlTransmitterCore_SimpleDualPortRAM_singlebit #(.AddrWidth(3),
                                                        .DataWidth(1)
                                                        )
                                                      u_Fec_Frame_FIFO (.clk(clk),
                                                                        .enb(enb),
                                                                        .wr_din(Delay17_out1),
                                                                        .wr_addr(Delay18_out1),
                                                                        .wr_en(Delay19_out1),
                                                                        .rd_addr(Delay20_out1),
                                                                        .dout(Fec_Frame_FIFO_out1)
                                                                        );

  always @(posedge clk)
    begin : Delay4_process
      if (enb) begin
        Delay4_reg[0] <= Fec_Frame_FIFO_out1;
        Delay4_reg[1] <= Delay4_reg[0];
      end
    end

  assign Delay4_out1 = Delay4_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          Delay2_reg[0] <= Delay4_out1;
          Delay2_reg[32'sd2:32'sd1] <= Delay2_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[2];



  assign fecframe = Delay2_out1;

  always @(posedge clk or posedge reset)
    begin : Delay22_process
      if (reset == 1'b1) begin
        Delay22_out1 <= 2'b00;
      end
      else begin
        if (enb) begin
          Delay22_out1 <= modIdxOut;
        end
      end
    end



  always @(posedge clk)
    begin : Delay24_process
      if (enb) begin
        for(Delay24_t_0_0 = 32'sd0; Delay24_t_0_0 <= 32'sd1; Delay24_t_0_0 = Delay24_t_0_0 + 32'sd1) begin
          Delay24_reg[Delay24_t_0_0] <= Delay24_reg_next[Delay24_t_0_0];
        end
      end
    end

  assign Delay24_out1 = Delay24_reg[1];
  assign Delay24_reg_next[0] = Delay22_out1;
  assign Delay24_reg_next[1] = Delay24_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay21_process
      if (reset == 1'b1) begin
        Delay21_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay21_out1 <= WriteVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay26_process
      if (enb) begin
        for(Delay26_t_0_0 = 32'sd0; Delay26_t_0_0 <= 32'sd1; Delay26_t_0_0 = Delay26_t_0_0 + 32'sd1) begin
          Delay26_reg[Delay26_t_0_0] <= Delay26_reg_next[Delay26_t_0_0];
        end
      end
    end

  assign Delay26_out1 = Delay26_reg[1];
  assign Delay26_reg_next[0] = Delay21_out1;
  assign Delay26_reg_next[1] = Delay26_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay23_process
      if (reset == 1'b1) begin
        Delay23_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay23_out1 <= writeVal;
        end
      end
    end



  always @(posedge clk)
    begin : Delay28_process
      if (enb) begin
        Delay28_reg[0] <= Delay23_out1;
        Delay28_reg[1] <= Delay28_reg[0];
      end
    end

  assign Delay28_out1 = Delay28_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay25_process
      if (reset == 1'b1) begin
        Delay25_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          Delay25_out1 <= ReadVal_Address_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay29_process
      if (enb) begin
        for(Delay29_t_0_0 = 32'sd0; Delay29_t_0_0 <= 32'sd1; Delay29_t_0_0 = Delay29_t_0_0 + 32'sd1) begin
          Delay29_reg[Delay29_t_0_0] <= Delay29_reg_next[Delay29_t_0_0];
        end
      end
    end

  assign Delay29_out1 = Delay29_reg[1];
  assign Delay29_reg_next[0] = Delay25_out1;
  assign Delay29_reg_next[1] = Delay29_reg[0];



  dvbs2hdlTransmitterCore_SimpleDualPortRAM_generic_block #(.AddrWidth(3),
                                                            .DataWidth(2)
                                                            )
                                                          u_Simple_Dual_Port_RAM2 (.clk(clk),
                                                                                   .enb(enb),
                                                                                   .wr_din(Delay24_out1),
                                                                                   .wr_addr(Delay26_out1),
                                                                                   .wr_en(Delay28_out1),
                                                                                   .rd_addr(Delay29_out1),
                                                                                   .dout(Simple_Dual_Port_RAM2_out1)
                                                                                   );

  always @(posedge clk or posedge reset)
    begin : Delay27_process
      if (reset == 1'b1) begin
        for(Delay27_t_1 = 32'sd0; Delay27_t_1 <= 32'sd4; Delay27_t_1 = Delay27_t_1 + 32'sd1) begin
          Delay27_reg[Delay27_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(Delay27_t_0_1 = 32'sd0; Delay27_t_0_1 <= 32'sd4; Delay27_t_0_1 = Delay27_t_0_1 + 32'sd1) begin
            Delay27_reg[Delay27_t_0_1] <= Delay27_reg_next[Delay27_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay27_out1 = Delay27_reg[4];
    Delay27_reg_next[0] = Simple_Dual_Port_RAM2_out1;

    for(Delay27_t_0_0 = 32'sd0; Delay27_t_0_0 <= 32'sd3; Delay27_t_0_0 = Delay27_t_0_0 + 32'sd1) begin
      Delay27_reg_next[Delay27_t_0_0 + 32'sd1] = Delay27_reg[Delay27_t_0_0];
    end

  end



  assign modIdx = Delay27_out1;

endmodule  // dvbs2hdlTransmitterCore_Parameter_Store_FIFO

