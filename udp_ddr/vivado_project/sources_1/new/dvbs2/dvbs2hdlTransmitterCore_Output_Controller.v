// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Output_Controller.v
// Created: 2024-01-10 13:49:57
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Output_Controller
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/FEC Encoder/DVB-S2 BCH Encoder/Output Controller
// Hierarchy Level: 5
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Output_Controller
          (clk,
           reset,
           enb,
           framLenDelayed,
           outputMsg,
           validMsg,
           outputParity,
           validParity,
           resetIn,
           parLen,
           outData,
           outCtrl_start,
           outCtrl_end,
           outCtrl_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [15:0] framLenDelayed;  // uint16
  input   outputMsg;
  input   validMsg;
  input   outputParity;
  input   validParity;
  input   resetIn;
  input   [7:0] parLen;  // uint8
  output  outData;
  output  outCtrl_start;
  output  outCtrl_end;
  output  outCtrl_valid;


  reg  [4:0] Delay1_reg;  // ufix1 [5]
  wire Delay1_out1;
  wire Logical_Operator4_out1;
  reg  Delay2_out1;
  wire [15:0] Add_stage2_add_temp;  // ufix16
  wire [15:0] Add_stage2_1;  // ufix16
  wire [16:0] Add_op_stage1;  // ufix17
  wire [15:0] Constant_out1;  // uint16
  wire [15:0] Add_stage3_add_cast;  // ufix16
  wire [15:0] Add_out1;  // uint16
  reg [15:0] Delay10_reg [0:2];  // ufix16 [3]
  reg [15:0] Delay10_reg_next [0:2];  // ufix16 [3]
  reg [15:0] Delay10_out1;  // uint16
  reg [15:0] Delay7_reg [0:4];  // ufix16 [5]
  reg [15:0] Delay7_reg_next [0:4];  // ufix16 [5]
  reg [15:0] Delay7_out1;  // uint16
  reg  [4:0] Delay4_reg;  // ufix1 [5]
  wire Delay4_out1;
  wire Logical_Operator2_out1;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] Output_Counter_out1;  // uint16
  wire [15:0] count;  // uint16
  wire need_to_wrap;
  wire [15:0] count_value;  // uint16
  wire [15:0] count_1;  // uint16
  wire Relational_Operator_relop1;
  wire Logical_Operator1_out1;
  wire Logical_Operator3_out1;
  wire [15:0] count_2;  // uint16
  wire Compare_To_Zero_out1;
  wire Logical_Operator_out1;
  reg  Delay3_out1;
  reg  Delay5_out1;
  reg  Delay6_out1;
  wire Sample_Control_Bus_Creator_out1_start;
  wire Sample_Control_Bus_Creator_out1_end;
  wire Sample_Control_Bus_Creator_out1_valid;
  reg signed [31:0] Delay10_t_0_0;  // int32
  reg signed [31:0] Delay10_t_0_1;  // int32
  reg signed [31:0] Delay10_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32

  // Output data and control generation
  // Next frame output port generation
  // Compare message plus parity length with output read Counter which reads the stored message and parity bits. 
  // Compare input frame length with input bit Counter without delay


  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= outputMsg;
          Delay1_reg[32'sd4:32'sd1] <= Delay1_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[4];



  assign Logical_Operator4_out1 = Delay1_out1 | outputParity;



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Logical_Operator4_out1;
        end
      end
    end



  assign outData = Delay2_out1;

  assign Add_stage2_1 = {8'b0, parLen};
  assign Add_stage2_add_temp = framLenDelayed + Add_stage2_1;
  assign Add_op_stage1 = {1'b0, Add_stage2_add_temp};



  assign Constant_out1 = 16'b0000000000000001;



  assign Add_stage3_add_cast = Add_op_stage1[15:0];
  assign Add_out1 = Add_stage3_add_cast + Constant_out1;



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        for(Delay10_t_1 = 32'sd0; Delay10_t_1 <= 32'sd2; Delay10_t_1 = Delay10_t_1 + 32'sd1) begin
          Delay10_reg[Delay10_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay10_t_0_1 = 32'sd0; Delay10_t_0_1 <= 32'sd2; Delay10_t_0_1 = Delay10_t_0_1 + 32'sd1) begin
            Delay10_reg[Delay10_t_0_1] <= Delay10_reg_next[Delay10_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay10_out1 = Delay10_reg[2];
    Delay10_reg_next[0] = Add_out1;

    for(Delay10_t_0_0 = 32'sd0; Delay10_t_0_0 <= 32'sd1; Delay10_t_0_0 = Delay10_t_0_0 + 32'sd1) begin
      Delay10_reg_next[Delay10_t_0_0 + 32'sd1] = Delay10_reg[Delay10_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd4; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd4; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
            Delay7_reg[Delay7_t_0_1] <= Delay7_reg_next[Delay7_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay7_out1 = Delay7_reg[4];
    Delay7_reg_next[0] = Delay10_out1;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd3; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next[Delay7_t_0_0 + 32'sd1] = Delay7_reg[Delay7_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg <= {5{1'b0}};
      end
      else begin
        if (enb) begin
          Delay4_reg[0] <= validMsg;
          Delay4_reg[32'sd4:32'sd1] <= Delay4_reg[32'sd3:32'sd0];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[4];



  assign Logical_Operator2_out1 = Delay4_out1 | validParity;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 65535
  assign count_step = 16'b0000000000000001;



  assign count_from = 16'b0000000000000000;



  assign count_reset = 16'b0000000000000000;



  assign count = Output_Counter_out1 + count_step;



  assign need_to_wrap = Output_Counter_out1 == 16'b1111111111111111;



  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);



  assign count_1 = (Logical_Operator2_out1 == 1'b0 ? Output_Counter_out1 :
              count_value);



  assign Relational_Operator_relop1 = Output_Counter_out1 >= Delay7_out1;



  assign Logical_Operator1_out1 = Relational_Operator_relop1 & Logical_Operator2_out1;



  assign Logical_Operator3_out1 = Logical_Operator1_out1 | resetIn;



  assign count_2 = (Logical_Operator3_out1 == 1'b0 ? count_1 :
              count_reset);



  always @(posedge clk or posedge reset)
    begin : Output_Counter_process
      if (reset == 1'b1) begin
        Output_Counter_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          Output_Counter_out1 <= count_2;
        end
      end
    end



  dvbs2hdlTransmitterCore_Compare_To_Zero u_Compare_To_Zero (.u(Output_Counter_out1),  // uint16
                                                             .y(Compare_To_Zero_out1)
                                                             );

  assign Logical_Operator_out1 = Compare_To_Zero_out1 & Logical_Operator2_out1;



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Logical_Operator_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Logical_Operator1_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Logical_Operator2_out1;
        end
      end
    end



  dvbs2hdlTransmitterCore_Sample_Control_Bus_Creator u_Sample_Control_Bus_Creator (.In1(Delay3_out1),
                                                                                   .In2(Delay5_out1),
                                                                                   .In3(Delay6_out1),
                                                                                   .Out1_start(Sample_Control_Bus_Creator_out1_start),
                                                                                   .Out1_end(Sample_Control_Bus_Creator_out1_end),
                                                                                   .Out1_valid(Sample_Control_Bus_Creator_out1_valid)
                                                                                   );

  assign outCtrl_start = Sample_Control_Bus_Creator_out1_start;

  assign outCtrl_end = Sample_Control_Bus_Creator_out1_end;

  assign outCtrl_valid = Sample_Control_Bus_Creator_out1_valid;

endmodule  // dvbs2hdlTransmitterCore_Output_Controller

