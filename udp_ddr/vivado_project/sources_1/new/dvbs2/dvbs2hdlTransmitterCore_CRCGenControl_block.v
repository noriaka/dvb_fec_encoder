// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_CRCGenControl_block.v
// Created: 2024-01-10 13:49:57
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_CRCGenControl_block
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/BB Frame Generator/BB Header and Data CRC Generator/Data Field 
// Generator/Packetized Streams/User Packet CRC Generator/CRCGenContro
// Hierarchy Level: 8
// Model version: 4.5
// 
// CRC Generator Control Signals Generation
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_CRCGenControl_block
          (clk,
           reset,
           enb,
           startIn,
           endIn,
           validIn,
           processMsg,
           padZero,
           outputCRC,
           endOut,
           validOut,
           counter,
           counter_outputCRC);


  input   clk;
  input   reset;
  input   enb;
  input   startIn;  // ufix1
  input   endIn;  // ufix1
  input   validIn;  // ufix1
  output  processMsg;  // ufix1
  output  padZero;  // ufix1
  output  outputCRC;  // ufix1
  output  endOut;  // ufix1
  output  validOut;  // ufix1
  output  [2:0] counter;  // ufix3
  output  [2:0] counter_outputCRC;  // ufix3


  reg  deofin;  // ufix1
  reg [2:0] cnt3out;  // ufix3
  wire processzero_short;  // ufix1
  wire cnt3enb;  // ufix1
  wire tsysenb_short;  // ufix1
  wire tprocessMsg;  // ufix1
  wire sysenb_short;  // ufix1
  wire ready;  // ufix1
  wire cnt1enb;  // ufix1
  reg [2:0] cnt2out;  // ufix3
  wire cnt2rst;  // ufix1
  wire cnt2enb;  // ufix1
  wire compare_cmpOut;
  wire [2:0] cnt2fstout;  // ufix3
  wire cnt2fstout_is_not0;
  wire cnt1rst;  // ufix1
  reg  cnt1out;  // ufix1
  wire processzero;  // ufix1
  wire tpadZero;  // ufix1
  wire cnt4rst;  // ufix1
  wire cnt5enb;  // ufix1
  reg [2:0] cnt5out;  // ufix3
  reg [2:0] cnt4out;  // ufix3
  reg  dteofout;  // ufix1
  wire rdteofout;  // ufix1
  wire sysenb;  // ufix1
  reg  udvalidin;  // ufix1
  wire rcnt3enb;  // ufix1
  wire clearvalidin;  // ufix1
  wire tvalidout;  // ufix1
  reg  [7:0] tvalidout_delay_register_reg;  // ufix1 [8]
  wire dvalidout;  // ufix1


  always @(posedge clk or posedge reset)
    begin : eofin_delay_register_process
      if (reset == 1'b1) begin
        deofin <= 1'b0;
      end
      else begin
        if (enb) begin
          deofin <= endIn;
        end
      end
    end



  assign processzero_short = cnt3out < 3'b111;



  assign tsysenb_short = cnt3enb & processzero_short;



  assign sysenb_short = tprocessMsg | tsysenb_short;



  assign ready =  ~ sysenb_short;



  assign cnt1enb = ready & startIn;



  // Counter 3 enable signal
  assign cnt3enb = cnt2out >= 3'b001;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  // Counter3: counts when start to pad zeros
  always @(posedge clk or posedge reset)
    begin : counter_1_process
      if (reset == 1'b1) begin
        cnt3out <= 3'b000;
      end
      else begin
        if (enb) begin
          if (cnt2rst == 1'b1) begin
            cnt3out <= 3'b000;
          end
          else if (cnt3enb == 1'b1) begin
            cnt3out <= cnt3out + 3'b001;
          end
        end
      end
    end



  assign cnt2rst = cnt3out == 3'b111;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 7
  //  count to value  = 1
  // Counter2: triggered by End of frame signal
  always @(posedge clk or posedge reset)
    begin : counter_2_process
      if (reset == 1'b1) begin
        cnt2out <= 3'b000;
      end
      else begin
        if (enb) begin
          if (cnt2rst == 1'b1) begin
            cnt2out <= 3'b000;
          end
          else if (cnt2enb == 1'b1) begin
            if (cnt2out == 3'b001) begin
              cnt2out <= 3'b000;
            end
            else begin
              cnt2out <= cnt2out + 3'b111;
            end
          end
        end
      end
    end



  assign compare_cmpOut = cnt2out == 3'b000;



  assign cnt2fstout = {2'b0, compare_cmpOut};



  assign cnt2fstout_is_not0 = cnt2fstout != 3'b000;



  // Counter 2 enable signal
  assign cnt2enb = tprocessMsg & deofin;



  assign cnt1rst = cnt2enb & cnt2fstout_is_not0;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 1
  // Counter1: triggered by Start of frame signal
  always @(posedge clk or posedge reset)
    begin : counter_3_process
      if (reset == 1'b1) begin
        cnt1out <= 1'b0;
      end
      else begin
        if (enb) begin
          if (cnt1rst == 1'b1) begin
            cnt1out <= 1'b0;
          end
          else if (cnt1enb == 1'b1) begin
            cnt1out <=  ~ cnt1out;
          end
        end
      end
    end



  assign tprocessMsg = cnt1out == 1'b1;



  // processMsg
  assign processMsg = tprocessMsg;

  assign processzero = 1'b1;



  assign tpadZero = cnt3enb & processzero;



  // padZero
  assign padZero = tpadZero;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  // Counter5: counts when start to output CRC
  always @(posedge clk or posedge reset)
    begin : counter_4_process
      if (reset == 1'b1) begin
        cnt5out <= 3'b000;
      end
      else begin
        if (enb) begin
          if (cnt4rst == 1'b1) begin
            cnt5out <= 3'b000;
          end
          else if (cnt5enb == 1'b1) begin
            cnt5out <= cnt5out + 3'b001;
          end
        end
      end
    end



  assign cnt4rst = cnt5out == 3'b111;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  // Counter4: triggered after processing all the padded zeros
  always @(posedge clk or posedge reset)
    begin : counter_5_process
      if (reset == 1'b1) begin
        cnt4out <= 3'b000;
      end
      else begin
        if (enb) begin
          if (cnt4rst == 1'b1) begin
            cnt4out <= 3'b000;
          end
          else if (cnt2rst == 1'b1) begin
            cnt4out <= cnt4out + 3'b001;
          end
        end
      end
    end



  // Counter 5 enable signal
  assign cnt5enb = cnt4out >= 3'b001;



  // outputCRC
  assign outputCRC = cnt5enb;

  always @(posedge clk or posedge reset)
    begin : eofout_delay_register_process
      if (reset == 1'b1) begin
        dteofout <= 1'b0;
      end
      else begin
        if (enb) begin
          dteofout <= cnt4rst;
        end
      end
    end



  assign rdteofout =  ~ dteofout;



  // End of frame output signal
  assign endOut = cnt4rst & rdteofout;



  assign sysenb = tprocessMsg | tpadZero;



  always @(posedge clk or posedge reset)
    begin : validin_unitdelay_register_process
      if (reset == 1'b1) begin
        udvalidin <= 1'b0;
      end
      else begin
        if (enb) begin
          udvalidin <= validIn;
        end
      end
    end



  assign rcnt3enb =  ~ cnt3enb;



  assign clearvalidin = (cnt3enb == 1'b0 ? udvalidin :
              rcnt3enb);



  assign tvalidout = sysenb & clearvalidin;



  // Buffer the validIn signal
  always @(posedge clk or posedge reset)
    begin : tvalidout_delay_register_process
      if (reset == 1'b1) begin
        tvalidout_delay_register_reg <= {8{1'b0}};
      end
      else begin
        if (enb) begin
          tvalidout_delay_register_reg[0] <= tvalidout;
          tvalidout_delay_register_reg[32'sd7:32'sd1] <= tvalidout_delay_register_reg[32'sd6:32'sd0];
        end
      end
    end

  assign dvalidout = tvalidout_delay_register_reg[7];



  // Data valid output
  assign validOut = dvalidout | cnt5enb;



  assign counter = cnt3out;

  assign counter_outputCRC = cnt5out;

endmodule  // dvbs2hdlTransmitterCore_CRCGenControl_block

