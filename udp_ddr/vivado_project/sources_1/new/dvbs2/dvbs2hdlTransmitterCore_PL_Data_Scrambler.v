// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_PL_Data_Scrambler.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_PL_Data_Scrambler
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/PL Frame Generator/PL Data Scrambler
// Hierarchy Level: 4
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_PL_Data_Scrambler
          (clk,
           reset,
           enb_1_8_0,
           dataIn_re,
           dataIn_im,
           startOfPlheader,
           endOfPlheader,
           validIn,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   signed [17:0] dataIn_re;  // sfix18_En16
  input   signed [17:0] dataIn_im;  // sfix18_En16
  input   startOfPlheader;
  input   endOfPlheader;
  input   validIn;
  output  signed [17:0] dataOut_re;  // sfix18_En16
  output  signed [17:0] dataOut_im;  // sfix18_En16
  output  validOut;


  reg  Delay26_out1;
  wire Unit_Delay_Enabled_Resettable_Synchronous_iv;
  reg  [1:0] delayMatch_reg;  // ufix1 [2]
  wire Unit_Delay_Enabled_Resettable_Synchronous_iv_1;
  reg  Unit_Delay_Enabled_Resettable_Synchronous_out1;
  wire Unit_Delay_Enabled_Resettable_Synchronous_ectrl;
  wire Unit_Delay_Enabled_Resettable_Synchronous_toDelay;
  reg  [12:0] Delay19_reg;  // ufix1 [13]
  wire Delay19_out1;
  reg signed [17:0] Delay9_reg_re [0:7];  // sfix18_En16 [8]
  reg signed [17:0] Delay9_reg_im [0:7];  // sfix18_En16 [8]
  reg signed [17:0] Delay9_reg_next_re [0:7];  // sfix18_En16 [8]
  reg signed [17:0] Delay9_reg_next_im [0:7];  // sfix18_En16 [8]
  reg signed [17:0] Delay9_out1_re;  // sfix18_En16
  reg signed [17:0] Delay9_out1_im;  // sfix18_En16
  reg signed [17:0] reduced_reg_re [0:1];  // sfix18_En16 [2]
  reg signed [17:0] reduced_reg_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] reduced_reg_next_re [0:1];  // sfix18_En16 [2]
  wire signed [17:0] reduced_reg_next_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay9_out1_re_1;  // sfix18_En16
  wire signed [17:0] Delay9_out1_im_1;  // sfix18_En16
  reg signed [17:0] Delay15_reg_re [0:1];  // sfix18_En16 [2]
  reg signed [17:0] Delay15_reg_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_reg_next_re [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_reg_next_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay15_out1_re;  // sfix18_En16
  wire signed [17:0] Delay15_out1_im;  // sfix18_En16
  reg  Delay25_out1;
  wire [1:0] PL_Scrambler_Gold_Sequence_Generator_out1;  // ufix2
  wire PL_Scrambler_Gold_Sequence_Generator_out2;
  reg [1:0] Delay2_out1;  // ufix2
  wire [1:0] prelookup_idx;  // ufix2
  wire signed [1:0] PL_Scramble_Sequence_Mapper_LUT_table_data [0:3];  // sfix2 [4]
  wire signed [1:0] realOut;  // sfix2
  reg signed [1:0] realOut_1;  // sfix2
  wire signed [1:0] PL_Scramble_Sequence_Mapper_LUT_table_data_1 [0:3];  // sfix2 [4]
  wire signed [1:0] imagOut;  // sfix2
  reg signed [1:0] imagOut_1;  // sfix2
  reg signed [1:0] Delay16_reg_re [0:1];  // sfix2 [2]
  reg signed [1:0] Delay16_reg_im [0:1];  // sfix2 [2]
  wire signed [1:0] Delay16_reg_next_re [0:1];  // sfix2 [2]
  wire signed [1:0] Delay16_reg_next_im [0:1];  // sfix2 [2]
  wire signed [1:0] Delay16_out1_re;  // sfix2
  wire signed [1:0] Delay16_out1_im;  // sfix2
  wire signed [19:0] Product_mul_temp;  // sfix20_En16
  wire signed [17:0] Product_Re_AC;  // sfix18_En16
  wire signed [19:0] Product1_mul_temp;  // sfix20_En16
  wire signed [17:0] Product_Im_AD;  // sfix18_En16
  wire signed [19:0] Product2_mul_temp;  // sfix20_En16
  wire signed [17:0] Product_Re_BD;  // sfix18_En16
  wire signed [17:0] mulOutput;  // sfix18_En16
  wire signed [19:0] Product3_mul_temp;  // sfix20_En16
  wire signed [17:0] Product_Im_BC;  // sfix18_En16
  wire signed [17:0] mulOutput_1;  // sfix18_En16
  reg signed [17:0] Delay20_reg_re [0:1];  // sfix18_En16 [2]
  reg signed [17:0] Delay20_reg_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay20_reg_next_re [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay20_reg_next_im [0:1];  // sfix18_En16 [2]
  wire signed [17:0] Delay20_out1_re;  // sfix18_En16
  wire signed [17:0] Delay20_out1_im;  // sfix18_En16
  reg signed [17:0] reduced_reg_re_1 [0:3];  // sfix18_En16 [4]
  reg signed [17:0] reduced_reg_im_1 [0:3];  // sfix18_En16 [4]
  reg signed [17:0] reduced_reg_next_re_1 [0:3];  // sfix18_En16 [4]
  reg signed [17:0] reduced_reg_next_im_1 [0:3];  // sfix18_En16 [4]
  reg signed [17:0] Delay9_out1_re_2;  // sfix18_En16
  reg signed [17:0] Delay9_out1_im_2;  // sfix18_En16
  wire signed [17:0] Switch_out1_re;  // sfix18_En16
  wire signed [17:0] Switch_out1_im;  // sfix18_En16
  reg signed [17:0] Delay22_out1_re;  // sfix18_En16
  reg signed [17:0] Delay22_out1_im;  // sfix18_En16
  reg  [6:0] Delay23_reg;  // ufix1 [7]
  wire Delay23_out1;
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_0_1;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] reduced_t_0_0;  // int32
  reg signed [31:0] reduced_t_1;  // int32
  reg signed [31:0] Delay15_t_0_0;  // int32
  reg signed [31:0] Delay15_t_1;  // int32
  reg signed [31:0] Delay16_t_0_0;  // int32
  reg signed [31:0] Delay16_t_1;  // int32
  reg signed [31:0] Delay20_t_0_0;  // int32
  reg signed [31:0] Delay20_t_1;  // int32
  reg signed [31:0] reduced_t_0_0_1;  // int32
  reg signed [31:0] reduced_t_0_1;  // int32

  initial begin

    for(Delay15_t_1 = 32'sd0; Delay15_t_1 <= 32'sd1; Delay15_t_1 = Delay15_t_1 + 32'sd1) begin
      Delay15_reg_re[Delay15_t_1] = 18'sb000000000000000000;
      Delay15_reg_im[Delay15_t_1] = 18'sb000000000000000000;
    end

    realOut_1 = 2'sb00;
    imagOut_1 = 2'sb00;

    for(Delay16_t_1 = 32'sd0; Delay16_t_1 <= 32'sd1; Delay16_t_1 = Delay16_t_1 + 32'sd1) begin
      Delay16_reg_re[Delay16_t_1] = 2'sb00;
      Delay16_reg_im[Delay16_t_1] = 2'sb00;
    end


    for(Delay20_t_1 = 32'sd0; Delay20_t_1 <= 32'sd1; Delay20_t_1 = Delay20_t_1 + 32'sd1) begin
      Delay20_reg_re[Delay20_t_1] = 18'sb000000000000000000;
      Delay20_reg_im[Delay20_t_1] = 18'sb000000000000000000;
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay26_process
      if (reset == 1'b1) begin
        Delay26_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay26_out1 <= endOfPlheader;
        end
      end
    end



  assign Unit_Delay_Enabled_Resettable_Synchronous_iv = 1'b0;



  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          delayMatch_reg[0] <= Unit_Delay_Enabled_Resettable_Synchronous_iv;
          delayMatch_reg[1] <= delayMatch_reg[0];
        end
      end
    end

  assign Unit_Delay_Enabled_Resettable_Synchronous_iv_1 = delayMatch_reg[1];



  assign Unit_Delay_Enabled_Resettable_Synchronous_ectrl = (startOfPlheader == 1'b0 ? Unit_Delay_Enabled_Resettable_Synchronous_out1 :
              startOfPlheader);



  assign Unit_Delay_Enabled_Resettable_Synchronous_toDelay = (Delay26_out1 == 1'b0 ? Unit_Delay_Enabled_Resettable_Synchronous_ectrl :
              Unit_Delay_Enabled_Resettable_Synchronous_iv_1);



  always @(posedge clk or posedge reset)
    begin : Unit_Delay_Enabled_Resettable_Synchronous_lowered_process
      if (reset == 1'b1) begin
        Unit_Delay_Enabled_Resettable_Synchronous_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Unit_Delay_Enabled_Resettable_Synchronous_out1 <= Unit_Delay_Enabled_Resettable_Synchronous_toDelay;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay19_process
      if (reset == 1'b1) begin
        Delay19_reg <= {13{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay19_reg[0] <= Unit_Delay_Enabled_Resettable_Synchronous_out1;
          Delay19_reg[32'sd12:32'sd1] <= Delay19_reg[32'sd11:32'sd0];
        end
      end
    end

  assign Delay19_out1 = Delay19_reg[12];



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd7; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg_re[Delay9_t_1] <= 18'sb000000000000000000;
          Delay9_reg_im[Delay9_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay9_t_0_1 = 32'sd0; Delay9_t_0_1 <= 32'sd7; Delay9_t_0_1 = Delay9_t_0_1 + 32'sd1) begin
            Delay9_reg_re[Delay9_t_0_1] <= Delay9_reg_next_re[Delay9_t_0_1];
            Delay9_reg_im[Delay9_t_0_1] <= Delay9_reg_next_im[Delay9_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay9_out1_re = Delay9_reg_re[7];
    Delay9_out1_im = Delay9_reg_im[7];
    Delay9_reg_next_re[0] = dataIn_re;
    Delay9_reg_next_im[0] = dataIn_im;

    for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd6; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
      Delay9_reg_next_re[Delay9_t_0_0 + 32'sd1] = Delay9_reg_re[Delay9_t_0_0];
      Delay9_reg_next_im[Delay9_t_0_0 + 32'sd1] = Delay9_reg_im[Delay9_t_0_0];
    end

  end



  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        for(reduced_t_1 = 32'sd0; reduced_t_1 <= 32'sd1; reduced_t_1 = reduced_t_1 + 32'sd1) begin
          reduced_reg_re[reduced_t_1] <= 18'sb000000000000000000;
          reduced_reg_im[reduced_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(reduced_t_0_0 = 32'sd0; reduced_t_0_0 <= 32'sd1; reduced_t_0_0 = reduced_t_0_0 + 32'sd1) begin
            reduced_reg_re[reduced_t_0_0] <= reduced_reg_next_re[reduced_t_0_0];
            reduced_reg_im[reduced_t_0_0] <= reduced_reg_next_im[reduced_t_0_0];
          end
        end
      end
    end

  assign Delay9_out1_re_1 = reduced_reg_re[1];
  assign Delay9_out1_im_1 = reduced_reg_im[1];
  assign reduced_reg_next_re[0] = Delay9_out1_re;
  assign reduced_reg_next_im[0] = Delay9_out1_im;
  assign reduced_reg_next_re[1] = reduced_reg_re[0];
  assign reduced_reg_next_im[1] = reduced_reg_im[0];



  always @(posedge clk)
    begin : Delay15_process
      if (enb_1_8_0) begin
        for(Delay15_t_0_0 = 32'sd0; Delay15_t_0_0 <= 32'sd1; Delay15_t_0_0 = Delay15_t_0_0 + 32'sd1) begin
          Delay15_reg_re[Delay15_t_0_0] <= Delay15_reg_next_re[Delay15_t_0_0];
          Delay15_reg_im[Delay15_t_0_0] <= Delay15_reg_next_im[Delay15_t_0_0];
        end
      end
    end

  assign Delay15_out1_re = Delay15_reg_re[1];
  assign Delay15_out1_im = Delay15_reg_im[1];
  assign Delay15_reg_next_re[0] = Delay9_out1_re_1;
  assign Delay15_reg_next_im[0] = Delay9_out1_im_1;
  assign Delay15_reg_next_re[1] = Delay15_reg_re[0];
  assign Delay15_reg_next_im[1] = Delay15_reg_im[0];



  always @(posedge clk or posedge reset)
    begin : Delay25_process
      if (reset == 1'b1) begin
        Delay25_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay25_out1 <= validIn;
        end
      end
    end



  dvbs2hdlTransmitterCore_PL_Scrambler_Gold_Sequence_Generator u_PL_Scrambler_Gold_Sequence_Generator (.clk(clk),
                                                                                                       .reset(reset),
                                                                                                       .enb_1_8_0(enb_1_8_0),
                                                                                                       .reset_1(Delay26_out1),
                                                                                                       .validIn(Delay25_out1),
                                                                                                       .dataOut(PL_Scrambler_Gold_Sequence_Generator_out1),  // ufix2
                                                                                                       .validOut(PL_Scrambler_Gold_Sequence_Generator_out2)
                                                                                                       );

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 2'b00;
      end
      else begin
        if (enb_1_8_0) begin
          Delay2_out1 <= PL_Scrambler_Gold_Sequence_Generator_out1;
        end
      end
    end



  assign prelookup_idx = (Delay2_out1 == 2'b00 ? 2'b00 :
              (Delay2_out1 == 2'b11 ? 2'b11 :
              Delay2_out1));



  assign PL_Scramble_Sequence_Mapper_LUT_table_data[0] = 2'sb01;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data[1] = 2'sb00;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data[2] = 2'sb11;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data[3] = 2'sb00;
  assign realOut = PL_Scramble_Sequence_Mapper_LUT_table_data[prelookup_idx];



  always @(posedge clk)
    begin : PipelineRegister_process
      if (enb_1_8_0) begin
        realOut_1 <= realOut;
      end
    end



  assign PL_Scramble_Sequence_Mapper_LUT_table_data_1[0] = 2'sb00;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data_1[1] = 2'sb01;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data_1[2] = 2'sb00;
  assign PL_Scramble_Sequence_Mapper_LUT_table_data_1[3] = 2'sb11;
  assign imagOut = PL_Scramble_Sequence_Mapper_LUT_table_data_1[prelookup_idx];



  always @(posedge clk)
    begin : PipelineRegister_1_process
      if (enb_1_8_0) begin
        imagOut_1 <= imagOut;
      end
    end



  always @(posedge clk)
    begin : Delay16_process
      if (enb_1_8_0) begin
        for(Delay16_t_0_0 = 32'sd0; Delay16_t_0_0 <= 32'sd1; Delay16_t_0_0 = Delay16_t_0_0 + 32'sd1) begin
          Delay16_reg_re[Delay16_t_0_0] <= Delay16_reg_next_re[Delay16_t_0_0];
          Delay16_reg_im[Delay16_t_0_0] <= Delay16_reg_next_im[Delay16_t_0_0];
        end
      end
    end

  assign Delay16_out1_re = Delay16_reg_re[1];
  assign Delay16_out1_im = Delay16_reg_im[1];
  assign Delay16_reg_next_re[0] = realOut_1;
  assign Delay16_reg_next_im[0] = imagOut_1;
  assign Delay16_reg_next_re[1] = Delay16_reg_re[0];
  assign Delay16_reg_next_im[1] = Delay16_reg_im[0];



  assign Product_mul_temp = Delay15_out1_re * Delay16_out1_re;
  assign Product_Re_AC = Product_mul_temp[17:0];



  assign Product1_mul_temp = Delay15_out1_re * Delay16_out1_im;
  assign Product_Im_AD = Product1_mul_temp[17:0];



  assign Product2_mul_temp = Delay15_out1_im * Delay16_out1_im;
  assign Product_Re_BD = Product2_mul_temp[17:0];



  assign mulOutput = Product_Re_AC - Product_Re_BD;



  assign Product3_mul_temp = Delay15_out1_im * Delay16_out1_re;
  assign Product_Im_BC = Product3_mul_temp[17:0];



  assign mulOutput_1 = Product_Im_AD + Product_Im_BC;



  always @(posedge clk)
    begin : Delay20_process
      if (enb_1_8_0) begin
        for(Delay20_t_0_0 = 32'sd0; Delay20_t_0_0 <= 32'sd1; Delay20_t_0_0 = Delay20_t_0_0 + 32'sd1) begin
          Delay20_reg_re[Delay20_t_0_0] <= Delay20_reg_next_re[Delay20_t_0_0];
          Delay20_reg_im[Delay20_t_0_0] <= Delay20_reg_next_im[Delay20_t_0_0];
        end
      end
    end

  assign Delay20_out1_re = Delay20_reg_re[1];
  assign Delay20_out1_im = Delay20_reg_im[1];
  assign Delay20_reg_next_re[0] = mulOutput;
  assign Delay20_reg_next_im[0] = mulOutput_1;
  assign Delay20_reg_next_re[1] = Delay20_reg_re[0];
  assign Delay20_reg_next_im[1] = Delay20_reg_im[0];



  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        for(reduced_t_1 = 32'sd0; reduced_t_1 <= 32'sd3; reduced_t_1 = reduced_t_1 + 32'sd1) begin
          reduced_reg_re_1[reduced_t_1] <= 18'sb000000000000000000;
          reduced_reg_im_1[reduced_t_1] <= 18'sb000000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(reduced_t_0_1 = 32'sd0; reduced_t_0_1 <= 32'sd3; reduced_t_0_1 = reduced_t_0_1 + 32'sd1) begin
            reduced_reg_re_1[reduced_t_0_1] <= reduced_reg_next_re_1[reduced_t_0_1];
            reduced_reg_im_1[reduced_t_0_1] <= reduced_reg_next_im_1[reduced_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay9_out1_re_2 = reduced_reg_re_1[3];
    Delay9_out1_im_2 = reduced_reg_im_1[3];
    reduced_reg_next_re_1[0] = Delay9_out1_re_1;
    reduced_reg_next_im_1[0] = Delay9_out1_im_1;

    for(reduced_t_0_0_1 = 32'sd0; reduced_t_0_0_1 <= 32'sd2; reduced_t_0_0_1 = reduced_t_0_0_1 + 32'sd1) begin
      reduced_reg_next_re_1[reduced_t_0_0_1 + 32'sd1] = reduced_reg_re_1[reduced_t_0_0_1];
      reduced_reg_next_im_1[reduced_t_0_0_1 + 32'sd1] = reduced_reg_im_1[reduced_t_0_0_1];
    end

  end



  assign Switch_out1_re = (Delay19_out1 == 1'b0 ? Delay20_out1_re :
              Delay9_out1_re_2);
  assign Switch_out1_im = (Delay19_out1 == 1'b0 ? Delay20_out1_im :
              Delay9_out1_im_2);



  always @(posedge clk or posedge reset)
    begin : Delay22_process
      if (reset == 1'b1) begin
        Delay22_out1_re <= 18'sb000000000000000000;
        Delay22_out1_im <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay22_out1_re <= Switch_out1_re;
          Delay22_out1_im <= Switch_out1_im;
        end
      end
    end



  assign dataOut_re = Delay22_out1_re;

  assign dataOut_im = Delay22_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay23_process
      if (reset == 1'b1) begin
        Delay23_reg <= {7{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay23_reg[0] <= PL_Scrambler_Gold_Sequence_Generator_out2;
          Delay23_reg[32'sd6:32'sd1] <= Delay23_reg[32'sd5:32'sd0];
        end
      end
    end

  assign Delay23_out1 = Delay23_reg[6];



  assign validOut = Delay23_out1;

endmodule  // dvbs2hdlTransmitterCore_PL_Data_Scrambler

