// -------------------------------------------------------------
// 
// File Name: F:\FileFolder\DVB\dvbs2_tx_new\hdlsrc\dvbs2hdlTransmitter\dvbs2hdlTransmitterCore\dvbs2hdlTransmitterCore_Generate_and_Add_Read_Base_Address.v
// Created: 2024-01-10 13:49:59
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: dvbs2hdlTransmitterCore_Generate_and_Add_Read_Base_Address
// Source Path: dvbs2hdlTransmitterCore/DVB-S2 Tx/Interleaver/DVB-S2 HDL Interleaver/RAM Address Generator/Generate 
// and Add Read Base Addres
// Hierarchy Level: 6
// Model version: 4.5
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module dvbs2hdlTransmitterCore_Generate_and_Add_Read_Base_Address
          (clk,
           reset,
           enb,
           readAddrIn,
           readValidIn,
           startIn,
           endIn,
           readAddrOut,
           readValidOut,
           readStartOut,
           readEndOut);


  input   clk;
  input   reset;
  input   enb;
  input   [16:0] readAddrIn;  // ufix17
  input   readValidIn;
  input   startIn;
  input   endIn;
  output  [17:0] readAddrOut;  // ufix18
  output  readValidOut;
  output  readStartOut;
  output  readEndOut;


  reg [16:0] Delay3_out1;  // ufix17
  reg [16:0] Delay13_reg [0:1];  // ufix17 [2]
  wire [16:0] Delay13_reg_next [0:1];  // ufix17 [2]
  wire [16:0] Delay13_out1;  // ufix17
  reg [16:0] Delay15_reg [0:1];  // ufix17 [2]
  wire [16:0] Delay15_reg_next [0:1];  // ufix17 [2]
  wire [16:0] Delay15_out1;  // ufix17
  reg  Delay_out1;
  reg  [1:0] Delay7_reg;  // ufix1 [2]
  wire Delay7_out1;
  reg  [1:0] Delay8_reg;  // ufix1 [2]
  wire Delay8_out1;
  wire Indicate_End_of_Every_ShortFrame_Length_Samples_out1;
  wire Logical_Operator_out1;
  wire [2:0] count_step;  // ufix3
  wire [2:0] count_from;  // ufix3
  reg [2:0] HDL_Counter_out1;  // ufix3
  wire [2:0] count;  // ufix3
  wire need_to_wrap;
  wire [2:0] count_value;  // ufix3
  wire [2:0] count_1;  // ufix3
  reg [2:0] Delay5_reg [0:1];  // ufix3 [2]
  wire [2:0] Delay5_reg_next [0:1];  // ufix3 [2]
  wire [2:0] Delay5_out1;  // ufix3
  wire [16:0] Gain_out1;  // ufix17
  reg [16:0] Delay6_reg [0:1];  // ufix17 [2]
  wire [16:0] Delay6_reg_next [0:1];  // ufix17 [2]
  wire [16:0] Delay6_out1;  // ufix17
  reg [16:0] Unit_Delay_Enabled_Synchronous3_out1;  // ufix17
  wire [16:0] Unit_Delay_Enabled_Synchronous3_ectrl;  // ufix17
  wire [17:0] Add_1;  // ufix18
  wire [17:0] Add_2;  // ufix18
  wire [17:0] Add_out1;  // ufix18
  reg  Delay4_out1;
  reg  [1:0] Delay14_reg;  // ufix1 [2]
  wire Delay14_out1;
  reg  [1:0] Delay16_reg;  // ufix1 [2]
  wire Delay16_out1;
  reg  Delay18_out1;
  reg  [1:0] Delay19_reg;  // ufix1 [2]
  wire Delay19_out1;
  reg  [1:0] Delay20_reg;  // ufix1 [2]
  wire Delay20_out1;
  reg  Delay1_out1;
  reg  [1:0] Delay9_reg;  // ufix1 [2]
  wire Delay9_out1;
  reg  [1:0] Delay11_reg;  // ufix1 [2]
  wire Delay11_out1;
  reg signed [31:0] Delay13_t_0_0;  // int32
  reg signed [31:0] Delay13_t_1;  // int32
  reg signed [31:0] Delay15_t_0_0;  // int32
  reg signed [31:0] Delay15_t_1;  // int32
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay6_t_0_0;  // int32
  reg signed [31:0] Delay6_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= readAddrIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        for(Delay13_t_1 = 32'sd0; Delay13_t_1 <= 32'sd1; Delay13_t_1 = Delay13_t_1 + 32'sd1) begin
          Delay13_reg[Delay13_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay13_t_0_0 = 32'sd0; Delay13_t_0_0 <= 32'sd1; Delay13_t_0_0 = Delay13_t_0_0 + 32'sd1) begin
            Delay13_reg[Delay13_t_0_0] <= Delay13_reg_next[Delay13_t_0_0];
          end
        end
      end
    end

  assign Delay13_out1 = Delay13_reg[1];
  assign Delay13_reg_next[0] = Delay3_out1;
  assign Delay13_reg_next[1] = Delay13_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        for(Delay15_t_1 = 32'sd0; Delay15_t_1 <= 32'sd1; Delay15_t_1 = Delay15_t_1 + 32'sd1) begin
          Delay15_reg[Delay15_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay15_t_0_0 = 32'sd0; Delay15_t_0_0 <= 32'sd1; Delay15_t_0_0 = Delay15_t_0_0 + 32'sd1) begin
            Delay15_reg[Delay15_t_0_0] <= Delay15_reg_next[Delay15_t_0_0];
          end
        end
      end
    end

  assign Delay15_out1 = Delay15_reg[1];
  assign Delay15_reg_next[0] = Delay13_out1;
  assign Delay15_reg_next[1] = Delay15_reg[0];



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay_out1 <= endIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay7_reg[0] <= Delay_out1;
          Delay7_reg[1] <= Delay7_reg[0];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay8_reg[0] <= Delay7_out1;
          Delay8_reg[1] <= Delay8_reg[0];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[1];



  dvbs2hdlTransmitterCore_Indicate_End_of_Every_ShortFrame_Length_Samples u_Indicate_End_of_Every_ShortFrame_Length_Samples (.readAddr(readAddrIn),  // ufix17
                                                                                                                             .endIndicate(Indicate_End_of_Every_ShortFrame_Length_Samples_out1)
                                                                                                                             );

  assign Logical_Operator_out1 = Indicate_End_of_Every_ShortFrame_Length_Samples_out1 & readValidIn;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 7
  assign count_step = 3'b001;



  assign count_from = 3'b000;



  assign count = HDL_Counter_out1 + count_step;



  assign need_to_wrap = HDL_Counter_out1 == 3'b111;



  assign count_value = (need_to_wrap == 1'b0 ? count :
              count_from);



  assign count_1 = (Logical_Operator_out1 == 1'b0 ? HDL_Counter_out1 :
              count_value);



  always @(posedge clk or posedge reset)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 3'b000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= count_1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd1; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_1] <= 3'b000;
        end
      end
      else begin
        if (enb) begin
          for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd1; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
            Delay5_reg[Delay5_t_0_0] <= Delay5_reg_next[Delay5_t_0_0];
          end
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[1];
  assign Delay5_reg_next[0] = HDL_Counter_out1;
  assign Delay5_reg_next[1] = Delay5_reg[0];



  assign Gain_out1 = 14'b11111101001000 * Delay5_out1;



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        for(Delay6_t_1 = 32'sd0; Delay6_t_1 <= 32'sd1; Delay6_t_1 = Delay6_t_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_1] <= 17'b00000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay6_t_0_0 = 32'sd0; Delay6_t_0_0 <= 32'sd1; Delay6_t_0_0 = Delay6_t_0_0 + 32'sd1) begin
            Delay6_reg[Delay6_t_0_0] <= Delay6_reg_next[Delay6_t_0_0];
          end
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[1];
  assign Delay6_reg_next[0] = Gain_out1;
  assign Delay6_reg_next[1] = Delay6_reg[0];



  assign Unit_Delay_Enabled_Synchronous3_ectrl = (Delay8_out1 == 1'b0 ? Unit_Delay_Enabled_Synchronous3_out1 :
              Delay6_out1);



  always @(posedge clk or posedge reset)
    begin : Unit_Delay_Enabled_Synchronous3_lowered_process
      if (reset == 1'b1) begin
        Unit_Delay_Enabled_Synchronous3_out1 <= 17'b00000000000000000;
      end
      else begin
        if (enb) begin
          Unit_Delay_Enabled_Synchronous3_out1 <= Unit_Delay_Enabled_Synchronous3_ectrl;
        end
      end
    end



  assign Add_1 = {1'b0, Delay15_out1};
  assign Add_2 = {1'b0, Unit_Delay_Enabled_Synchronous3_out1};
  assign Add_out1 = Add_1 + Add_2;



  assign readAddrOut = Add_out1;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= readValidIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay14_reg[0] <= Delay4_out1;
          Delay14_reg[1] <= Delay14_reg[0];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay16_process
      if (reset == 1'b1) begin
        Delay16_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay16_reg[0] <= Delay14_out1;
          Delay16_reg[1] <= Delay16_reg[0];
        end
      end
    end

  assign Delay16_out1 = Delay16_reg[1];



  assign readValidOut = Delay16_out1;

  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay18_out1 <= startIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay19_process
      if (reset == 1'b1) begin
        Delay19_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay19_reg[0] <= Delay18_out1;
          Delay19_reg[1] <= Delay19_reg[0];
        end
      end
    end

  assign Delay19_out1 = Delay19_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay20_process
      if (reset == 1'b1) begin
        Delay20_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay20_reg[0] <= Delay19_out1;
          Delay20_reg[1] <= Delay20_reg[0];
        end
      end
    end

  assign Delay20_out1 = Delay20_reg[1];



  assign readStartOut = Delay20_out1;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay1_out1 <= endIn;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay9_reg[0] <= Delay1_out1;
          Delay9_reg[1] <= Delay9_reg[0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[1];



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Delay11_reg[0] <= Delay9_out1;
          Delay11_reg[1] <= Delay11_reg[0];
        end
      end
    end

  assign Delay11_out1 = Delay11_reg[1];



  assign readEndOut = Delay11_out1;

endmodule  // dvbs2hdlTransmitterCore_Generate_and_Add_Read_Base_Address

